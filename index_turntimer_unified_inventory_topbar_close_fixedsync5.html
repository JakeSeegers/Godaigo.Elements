<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Godaigo - Hexagon Tile Game</title>
    <!-- Supabase -->
    <script src="https://unpkg.com/@supabase/supabase-js@2.39.3/dist/umd/supabase.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: #111;
            font-family: 'Courier New', monospace;
            color: #eee;
            user-select: none;
        }

        h1 {
            color: #d9b08c;
            text-shadow: 0 0 5px #b75000;
            text-align: center;
            margin-top: 0;
        }

        .game-container {
            display: flex;
            gap: 20px;
            max-width: 1400px;
        }

        
        /* Inventory toggle: hide/show the side deck-panel for both desktop and mobile */
        .game-container.inventory-collapsed .deck-panel {
            display: none;
        }
        .game-container.inventory-open .deck-panel {
            display: flex;
        }
        /* Let the board expand when inventory is hidden */
        .board-container {
            flex: 1;
        }
.deck-panel {
            background: #222;
            padding: 12px 12px;
            border-radius: 10px;
            width: 100%;
            display: flex;
            flex-direction: row;
            gap: 18px;
            align-items: flex-start;
            overflow-x: auto;
        }

        .deck-panel h3 {
            margin-top: 0;
            text-align: center;
            color: #d9b08c;
        }

        /* Inventory top bar tweaks */
        .deck-panel h3 {
            text-align: left;
        }

        /* Inventory header with close button (visible on mobile + desktop) */
        .inventory-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 8px 10px;
            margin-bottom: 8px;
            border-bottom: 1px solid rgba(217,176,140,0.35);
        }
        .inventory-title {
            font-weight: 700;
            color: #d9b08c;
        }
        .inventory-close-btn {
            background: rgba(217,176,140,0.18);
            border: 1px solid rgba(217,176,140,0.45);
            color: #d9b08c;
            border-radius: 10px;
            padding: 6px 10px;
            font-size: 14px;
            cursor: pointer;
        }
        .inventory-close-btn:active {
            transform: translateY(1px);
        }

        /* Never show the main tile deck (only player tiles + stones are relevant) */
        #tile-deck-header,
        #tile-deck-container {
            display: none !important;
        }
/* Never show the shared tile deck indicator/icon */
        #tile-deck-header, #tile-deck-container {
            display: none !important;
        }

        /* Make inventory content horizontal */
        .deck-panel .tile-deck {
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: flex-start;
            align-items: center;
            gap: 12px;
        }
        .deck-panel .stone-deck {
            flex-direction: row;
            flex-wrap: wrap;
            justify-content: flex-start;
            align-items: flex-start;
            gap: 12px;
        }
        .deck-panel .stone-deck-item {
            min-width: 72px;
        }

        .tile-deck, .stone-deck {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        .deck-tile {
            cursor: grab;
            transition: transform 0.2s;
        }

        .deck-tile:hover {
            transform: scale(1.05);
        }

        .deck-tile:active {
            cursor: grabbing;
        }

        .board-container {
            background: #222;
            border-radius: 10px;
            padding: 20px;
            position: relative;
            overflow: auto;
        }

        svg {
            display: block;
        }

        .hex-tile {
            fill: #d4a574;
            stroke: #2c3e50;
            stroke-width: 2;
        }

        .hex-tile.flipped {
            fill: #8b7355;
        }

        .hex-tile.empty-center {
            fill: none;
        }

        .placed-tile.player-tile .hex-tile {
            fill: #8b7355;
        }

        .placed-tile.player-tile .hex-tile.empty-center {
            fill: none;
        }

        .placed-tile {
            cursor: grab;
        }

        .placed-tile.has-stones {
            cursor: not-allowed;
        }

        .placed-tile:hover .hex-tile {
            stroke: #3498db;
            stroke-width: 4;
        }

        .ghost-tile {
            opacity: 0.4;
        }

        .shrine-marker {
            pointer-events: none;
        }

        .shrine-marker circle {
            filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.5));
        }

        .controls {
            background: #222;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .player-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .action-points {
            background: #333;
            padding: 5px 10px;
            border-radius: 5px;
        }

        .stone-deck-item {
            cursor: grab;
            padding: 10px;
            background: #333;
            border-radius: 5px;
            text-align: center;
        }

        .stone-deck-item:hover {
            background: #444;
        }

        .stone-count {
            font-size: 12px;
            text-align: center;
            margin-top: 5px;
            font-weight: bold;
            color: #fff;
        }

        .source-count {
            font-size: 10px;
            text-align: center;
            margin-top: 2px;
            color: #999;
        }

        button {
            background: #b75000;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
        }

        button:hover {
            background: #d9b08c;
            color: #333;
        }

        #status {
            padding: 5px 10px;
            border-radius: 5px;
            background: #333;
            min-height: 20px;
            margin-top: 10px;
        }

        .snap-indicator {
            fill: none;
            stroke: #2ecc71;
            stroke-width: 4;
            opacity: 0;
            pointer-events: none;
        }

        .snap-indicator.active {
            opacity: 0.8;
        }

        .stone {
            cursor: grab;
            pointer-events: all;
            z-index: 100;
        }

        .stone:hover:not(.stone-ghost) .stone-piece {
            stroke-width: 3;
        }

        .stone:active {
            cursor: grabbing;
        }

        .stone-piece {
            stroke: #000;
            stroke-width: 2;
        }

        .stone-ghost {
            opacity: 0.5;
            transition: none;
            pointer-events: none;
        }

        .player {
            cursor: grab;
            pointer-events: all;
            z-index: 150;
        }

        .player:hover .player-marker {
            stroke-width: 3;
        }

        .player:active {
            cursor: grabbing;
        }

        .player-marker {
            /* fill color is set inline based on player color */
            stroke: #000;
            stroke-width: 2;
        }

        .teleport-indicator {
            cursor: pointer;
            pointer-events: all;
        }

        .teleport-indicator:hover {
            opacity: 0.8 !important;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.1); opacity: 0.7; }
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Player tile tooltip */
        .player-tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #d9b08c;
            pointer-events: none;
            z-index: 10000;
            font-size: 14px;
            min-width: 200px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .player-tooltip .tooltip-header {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 10px;
            border-bottom: 1px solid #d9b08c;
            padding-bottom: 5px;
        }

        .player-tooltip .tooltip-row {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
        }

        .player-tooltip .tooltip-label {
            color: #999;
        }

        /* Mobile-specific styles */
        .mobile-deck-container {
            display: none;
        }

        @media (max-width: 768px) and (orientation: portrait) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 24px;
                margin: 10px 0;
            }

            .game-container {
                flex-direction: column;
                width: 100%;
                gap: 10px;
            }
/* Show mobile deck container */
            .mobile-deck-container {
                display: none;
                position: fixed;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                z-index: 100;
            }

            .mobile-tab-buttons {
                display: flex;
                flex-direction: column;
                gap: 5px;
                background: #222;
                border-radius: 10px 0 0 10px;
                padding: 10px 5px;
            }

            .mobile-tab-btn {
                background: #333;
                border: none;
                color: #d9b08c;
                padding: 15px 10px;
                border-radius: 5px;
                cursor: pointer;
                font-size: 12px;
                font-family: 'Courier New', monospace;
                min-width: 50px;
                transition: background 0.2s;
            }

            .mobile-tab-btn.active {
                background: #d9b08c;
                color: #111;
            }

            .mobile-tab-btn:hover {
                background: #444;
            }

            .mobile-tab-btn.active:hover {
                background: #c9a07c;
            }

            .mobile-deck-panel {
                position: fixed;
                right: -280px;
                top: 50%;
                transform: translateY(-50%);
                width: 250px;
                max-height: 80vh;
                background: #222;
                border-radius: 10px 0 0 10px;
                padding: 15px;
                transition: right 0.3s ease;
                overflow-y: auto;
                z-index: 99;
            }
            .mobile-deck-container.collapsed .mobile-deck-panel {
                display: none !important;
            }
            .mobile-deck-container.collapsed {
                width: auto;
                opacity: 0.9;
            }


            .mobile-deck-panel.active {
                right: 60px;
            }

            .mobile-deck-panel h3 {
                margin-top: 0;
                color: #d9b08c;
                text-align: center;
                font-size: 16px;
            }

            .mobile-tile-grid, .mobile-stone-grid {
                display: flex;
                flex-direction: column;
                gap: 10px;
                align-items: center;
            }

            .board-container {
                width: 100%;
                height: calc(100vh - 180px);
                padding: 10px;
                overflow: hidden;
            }

            #boardSvg {
                width: 100%;
                height: 100%;
            }

            .controls {
                padding: 10px;
                margin-top: 10px;
            }

            #status {
                font-size: 12px;
            }

            /* Larger touch targets for mobile */
            .placed-tile {
                cursor: pointer;
            }

            .deck-tile {
                cursor: pointer;
                touch-action: none;
            }

            .stone-deck-item {
                touch-action: none;
                padding: 15px;
                font-size: 16px;
            }

            /* Enlarge snap indicator for touch */
            .snap-indicator {
                r: 15;
            }
        }
    </style>
</head>
<body>
    <h1>Godaigo - Hexagon Tile Game</h1>

    <!-- Multiplayer Lobby -->
    <div id="multiplayer-lobby" style="background: #222; padding: 30px; border-radius: 10px; margin-bottom: 20px; max-width: 600px;">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <h2 style="color: #d9b08c; margin-top: 0;">Multiplayer Lobby</h2>
            <button onclick="resetLobby()"
                    style="padding: 8px 15px; font-size: 14px; background: #f44336; color: white; border: none; border-radius: 5px; cursor: pointer;">
                üîÑ Reset Lobby
            </button>
        </div>

        <!-- Join Form -->
        <div id="join-form" style="margin-bottom: 20px;">
            <input type="text" id="username-input" placeholder="Enter your username"
                   style="padding: 10px; font-size: 16px; width: 300px; background: #333; color: #eee; border: 2px solid #666; border-radius: 5px;">
            <button id="join-button" onclick="joinLobby()"
                    style="padding: 10px 20px; font-size: 16px; margin-left: 10px;">Join Game</button>
            <div id="join-loading" style="display: none; margin-top: 15px; text-align: center;">
                <div style="display: inline-block; width: 30px; height: 30px; border: 3px solid #666; border-top: 3px solid #d9b08c; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                <p style="color: #d9b08c; margin-top: 10px;">Joining lobby...</p>
            </div>
        </div>
        
        <!-- Player List -->
        <div id="player-list" style="background: #333; padding: 20px; border-radius: 5px; margin-bottom: 20px; min-height: 100px;">
            <h3 style="margin-top: 0; color: #d9b08c;">Players in Lobby:</h3>
            <div id="players-container" style="color: #eee;"></div>
        </div>
        
        <!-- Ready Button (hidden until joined) -->
        <div id="ready-controls" style="display: none; text-align: center;">
            <button id="ready-button" onclick="toggleReady()"
                    style="padding: 15px 40px; font-size: 18px; background: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">
                I'm Ready!
            </button>

            <!-- Host-only Settings & Start Game -->
            <div id="host-settings" style="display: none; margin-top: 20px; background: #333; padding: 15px; border-radius: 5px;">
                <h4 style="color: #d9b08c; margin-top: 0;">Host Settings</h4>

                <div style="margin-bottom: 10px;">
                    <label style="color: #eee; display: block; margin-bottom: 5px;">Turn Time Limit:</label>
                    <select id="timeout-setting" style="padding: 8px; background: #444; color: #eee; border: 1px solid #666; border-radius: 5px;">
                        <option value="0">Disabled</option>
                        <option value="30">30 seconds</option>
                        <option value="60">1 minute</option>
                        <option value="120" selected>2 minutes</option>
                        <option value="180">3 minutes</option>
                        <option value="300">5 minutes</option>
                    </select>
                    <label style="color: #eee; display: flex; align-items: center; gap: 8px; margin-top: 10px;">
                        <input type="checkbox" id="kick-on-timeout" checked>
                        Kick active player when turn timer expires
                    </label>
                    <div style="color: #999; font-size: 12px; margin-top: 6px;">
                        If disabled, expired turns will auto-pass to the next player.
                    </div>
                </div>

                <button id="host-start-button" onclick="hostStartGame()"
                        style="padding: 15px 40px; font-size: 18px; background: #FF9800; color: white; border: none; border-radius: 5px; cursor: pointer; width: 100%;">
                    Start Game (Host)
                </button>
            </div>

            <p id="lobby-instruction" style="color: #999; margin-top: 10px; font-size: 14px;">
                The host can start the game when 2-5 players have joined
            </p>
        </div>
        
        <!-- Status -->
        <div id="lobby-status" style="text-align: center; color: #999; margin-top: 15px;"></div>
    </div>

    <!-- Old player selection (hidden, for fallback/testing) -->
    <div id="player-selection" style="display: none; background: #222; padding: 30px; border-radius: 10px; margin-bottom: 20px; text-align: center;">
        <h2 style="color: #d9b08c; margin-top: 0;">Select Number of Players (Local)</h2>
        <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
            <button onclick="startGame(1)" style="padding: 15px 30px; font-size: 18px;">1 Player</button>
            <button onclick="startGame(2)" style="padding: 15px 30px; font-size: 18px;">2 Players</button>
            <button onclick="startGame(3)" style="padding: 15px 30px; font-size: 18px;">3 Players</button>
            <button onclick="startGame(4)" style="padding: 15px 30px; font-size: 18px;">4 Players</button>
            <button onclick="startGame(5)" style="padding: 15px 30px; font-size: 18px;">5 Players</button>
        </div>
        <p style="color: #999; margin-top: 15px; font-size: 14px;">
            1 player = 6 tiles (1 of each type)<br>
            Each additional player adds 6 more tiles in a spiral pattern
        </p>
    </div>

    <div class="game-container inventory-collapsed" style="display: none;">
        <div class="deck-panel">
            <div class="inventory-header">
                <div class="inventory-title">üéí Inventory</div>
                <button id="inventory-close" class="inventory-close-btn" aria-label="Close inventory">‚úï</button>
            </div>

            <h3 id="tile-deck-header">Tile Deck (<span id="deck-count">0/24</span>)</h3>
            <div class="tile-deck" id="tile-deck-container">
                <svg width="150" height="150" class="deck-tile" id="deckTile"></svg>
            </div>

            <h3 id="player-tiles-header" style="margin-top: 30px;">Player Tiles (<span id="player-tile-count">0</span>)</h3>
            <div class="tile-deck" id="player-tile-deck">
                <!-- Player tiles will be added here dynamically -->
            </div>

            <h3 style="margin-top: 30px;">Player Pool</h3>
            <div class="stone-deck">
                <div class="stone-deck-item" id="earth-deck">
                    <svg width="40" height="40">
                        <circle cx="20" cy="20" r="12" fill="#69d83a" class="stone-piece"/>
                        <text x="20" y="20" text-anchor="middle" dominant-baseline="middle" fill="#fff" font-size="14" font-weight="bold">‚ñ≤</text>
                    </svg>
                    <div class="stone-count" id="earth-count">0/5</div>
                    <div class="source-count" id="earth-source">20/25</div>
                </div>
                <div class="stone-deck-item" id="water-deck">
                    <svg width="40" height="40">
                        <circle cx="20" cy="20" r="12" fill="#5894f4" class="stone-piece"/>
                        <text x="20" y="20" text-anchor="middle" dominant-baseline="middle" fill="#fff" font-size="14" font-weight="bold">‚óØ</text>
                    </svg>
                    <div class="stone-count" id="water-count">0/5</div>
                    <div class="source-count" id="water-source">20/25</div>
                </div>
                <div class="stone-deck-item" id="fire-deck">
                    <svg width="40" height="40">
                        <circle cx="20" cy="20" r="12" fill="#ed1b43" class="stone-piece"/>
                        <text x="20" y="20" text-anchor="middle" dominant-baseline="middle" fill="#fff" font-size="14" font-weight="bold">‚ô¶</text>
                    </svg>
                    <div class="stone-count" id="fire-count">0/5</div>
                    <div class="source-count" id="fire-source">20/25</div>
                </div>
                <div class="stone-deck-item" id="wind-deck">
                    <svg width="40" height="40">
                        <circle cx="20" cy="20" r="12" fill="#ffce00" class="stone-piece"/>
                        <text x="20" y="20" text-anchor="middle" dominant-baseline="middle" fill="#fff" font-size="14" font-weight="bold">‚âã</text>
                    </svg>
                    <div class="stone-count" id="wind-count">0/5</div>
                    <div class="source-count" id="wind-source">20/25</div>
                </div>
                <div class="stone-deck-item" id="void-deck">
                    <svg width="40" height="40">
                        <circle cx="20" cy="20" r="12" fill="#9458f4" class="stone-piece"/>
                        <text x="20" y="20" text-anchor="middle" dominant-baseline="middle" fill="#fff" font-size="14" font-weight="bold">‚ú∫</text>
                    </svg>
                    <div class="stone-count" id="void-count">0/5</div>
                    <div class="source-count" id="void-source">20/25</div>
                </div>
            </div>
        </div>

        <div style="display: flex; flex-direction: column;">
            <div class="board-container">
                <svg id="boardSvg" width="1000" height="800">
                    <g id="viewport">
                        <circle class="snap-indicator" id="snapIndicator" r="10" cx="0" cy="0"/>
                    </g>
                </svg>
            </div>

            <div class="controls">
                <div class="player-info">
                    <div class="action-points">
                        AP: <span id="ap-count">5</span>/5
                        <span id="void-ap-display" style="color: #9458f4; margin-left: 10px;"></span>
                        <span id="inactivity-timer" style="display: none; margin-left: 15px; padding: 5px 10px; border-radius: 5px; font-weight: bold;"></span>
                    </div>
                    <button id="inventory-toggle" title="Show/hide inventory">üéí Inventory</button>
                    <button id="end-turn" style="display: none;">End Turn</button>
                    <button id="undo-move">Undo Move</button>
                    <button id="scroll-inventory">üìú Scrolls (<span id="scroll-count">0</span>)</button>
                    <button id="cast-spell">‚ú® Cast Spell (2 AP)</button>
                                        <button id="leave-game" style="display: none; background: #f44336;">Leave Game</button>
                </div>

                <div id="status">Drag tiles from the deck to build your board. Drag stones onto hexes.<br>
                <small style="color: #999;">All stones: 1 AP baseline | üî• Fire destroys adjacent non-void | üíß Water (2 AP) chains abilities | üå™Ô∏è Wind free movement | üóª Earth blocks | ‚ú® Void nullifies</small></div>
            </div>
        </div>
    </div>

    <!-- Mobile Deck UI (hidden on desktop) -->
    <div class="mobile-deck-container">
        <div class="mobile-tab-buttons">
            <button class="mobile-tab-btn active" data-tab="tiles">
                Tiles
            </button>
            <button class="mobile-tab-btn" data-tab="stones">
                Stones
            </button>
        </div>

        <div class="mobile-deck-panel" id="mobile-tiles-panel">
            <h3>Tiles (<span id="mobile-tile-count">0</span>)</h3>
            <div class="mobile-tile-grid" id="mobile-tile-grid">
                <!-- Tiles will be added here dynamically -->
            </div>
        </div>

        <div class="mobile-deck-panel" id="mobile-stones-panel">
            <h3>Stones</h3>
            <div class="mobile-stone-grid" id="mobile-stone-grid">
                <!-- Stones will be added here dynamically -->
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // SUPABASE MULTIPLAYER SETUP
        // ========================================
        const SUPABASE_URL = 'https://lovybwpypkaarstnvkbz.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imxvdnlid3B5cGthYXJzdG52a2J6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjkwMzI4NTgsImV4cCI6MjA4NDYwODg1OH0.lqobDTaopRJ5sA0yZQvzDwudq2x4zz9HMtTkSuJulFU';
        
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
        
        // Multiplayer state
        let myPlayerId = null;
        let myPlayerIndex = null;
        let totalPlayers = 0; // Total number of players in the game
        let playerTilesPlaced = new Set(); // Track which player indices have placed tiles
        let isPlacementPhase = false;
        // Mobile deck initial state is set later after isMobile is computed
        let allPlayersData = []; // Store all player data from database (id, player_index, color, username)

        // Helper function to get player display name (Username (Color))
        function getPlayerColorName(playerIndex) {
            const colorNames = {
                'purple': 'Purple',
                'yellow': 'Yellow',
                'red': 'Red',
                'blue': 'Blue',
                'green': 'Green'
            };

            let username = null;
            let colorName = null;

            // Try to get from database player data first
            if (allPlayersData.length > 0) {
                const player = allPlayersData.find(p => p.player_index === playerIndex);
                if (player) {
                    username = player.username;
                    if (player.color) {
                        colorName = colorNames[player.color] || player.color;
                    }
                }
            }

            // Fallback to playerPositions if player tile is placed
            if (!colorName && playerPositions[playerIndex]) {
                const hexColorNames = {
                    '#9458f4': 'Purple',
                    '#ffce00': 'Yellow',
                    '#ed1b43': 'Red',
                    '#5894f4': 'Blue',
                    '#69d83a': 'Green'
                };
                colorName = hexColorNames[playerPositions[playerIndex].color] || 'Player ' + (playerIndex + 1);
            }

            // Build display name: "Username (Color)" or just "Color" or "Player X"
            if (username && colorName) {
                return username + ' (' + colorName + ')';
            } else if (colorName) {
                return colorName;
            } else if (username) {
                return username;
            } else {
                return 'Player ' + (playerIndex + 1);
            }
        }

        // Check if it's the current player's turn (for multiplayer)
        // This is for GAME ACTIONS (moving, placing stones, etc), NOT tile placement
        function isMyTurn() {
            if (!isMultiplayer) return true; // In local mode, always allow actions
            if (isPlacementPhase) return false; // During placement phase, no game actions allowed
            return myPlayerIndex === activePlayerIndex;
        }

        // Show/hide End Turn button based on whose turn it is
        function updateEndTurnButtonVisibility() {
            const btn = document.getElementById('end-turn');
            if (!btn) return;

            // In local mode, keep it visible
            if (!isMultiplayer) {
                btn.style.display = '';
                return;
            }

            // In multiplayer, only show on your turn (and never during placement phase)
            btn.style.display = isMyTurn() ? '' : 'none';
        }

        // Hide deck indicators during play (keep deck panel for stones/player pool)
        function updateDeckIndicatorVisibility() {
            const gameContainer = document.querySelector('.game-container');
            const inGame = gameContainer && gameContainer.style.display !== 'none';
            const hide = inGame && !isPlacementPhase; // hide during main play

            const tileDeckHeader = document.getElementById('tile-deck-header');
            const tileDeckContainer = document.getElementById('tile-deck-container');
            const playerTilesHeader = document.getElementById('player-tiles-header');

            if (tileDeckHeader) tileDeckHeader.style.display = hide ? 'none' : '';
            if (tileDeckContainer) tileDeckContainer.style.display = hide ? 'none' : '';
            if (playerTilesHeader) playerTilesHeader.style.display = hide ? 'none' : '';
        }

        // Inventory panel toggle (unified for desktop + mobile)
        let isInventoryOpen = false;

        function setInventoryOpen(open) {
            isInventoryOpen = !!open;
            const gameContainer = document.querySelector('.game-container');
            if (!gameContainer) return;

            gameContainer.classList.toggle('inventory-open', isInventoryOpen);
            gameContainer.classList.toggle('inventory-collapsed', !isInventoryOpen);

            const btn = document.getElementById('inventory-toggle');
            if (btn) {
                btn.textContent = isInventoryOpen ? 'üéí Inventory (hide)' : 'üéí Inventory';
            }
        }

        function toggleInventory() {
            setInventoryOpen(!isInventoryOpen);
        }

        // Close button inside inventory (useful on mobile where bottom controls may be off-screen)
        document.addEventListener('DOMContentLoaded', () => {
            const closeBtn = document.getElementById('inventory-close');
            if (closeBtn) closeBtn.addEventListener('click', () => setInventoryOpen(false));
        });



        // Check if current player can place their tile during placement phase
        // This is ONLY for player tile placement
        function canPlaceTile() {
            if (!isMultiplayer) return true;
            if (!isPlacementPhase) return false; // Player tiles can only be placed during placement phase
            // During placement phase, only the active player can place their tile
            return myPlayerIndex === activePlayerIndex && !playerTilesPlaced.has(myPlayerIndex);
        }

        // Show "not your turn" message
        function notYourTurn() {
            if (isPlacementPhase) {
                const activeColor = getPlayerColorName(activePlayerIndex);
                updateStatus(`‚è≥ Waiting for ${activeColor} to place their tile... (${playerTilesPlaced.size}/${totalPlayers})`);
            } else {
                const activeColor = getPlayerColorName(activePlayerIndex);
                updateStatus(`‚è≥ Not your turn! It's ${activeColor}'s turn.`);
            }
        }

        // Update turn display when turn changes
        function updateTurnDisplay() {
            if (!isMultiplayer) return;

            updateEndTurnButtonVisibility();
            updateDeckIndicatorVisibility();

            const myColorName = getPlayerColorName(myPlayerIndex);
            const activeColorName = getPlayerColorName(activePlayerIndex);

            if (isMyTurn()) {
                updateStatus(`‚úÖ It's your turn! You are ${myColorName}.`);
                console.log('‚úÖ My turn now!');
            } else {
                updateStatus(`‚è≥ Waiting... ${activeColorName}'s turn.`);
                console.log(`‚è≥ Waiting for player ${activePlayerIndex + 1}`);
            }

            // Note: Each player always sees their own inventory (stones/scrolls/AP)
            // We don't update inventory here - it stays showing the local player's resources
        }

        let isMultiplayer = false;
        let gameRoomSubscription = null;
        let playersSubscription = null;
        let gameStateSubscription = null;
        
        // ========================================
        // GAME CONSTANTS
        // ========================================
        const TILE_SIZE = 20;
        const SNAP_THRESHOLD = 40;
        const STONE_SIZE = 12;

        const STONE_TYPES = {
            earth: { color: '#69d83a', symbol: '‚ñ≤' },
            water: { color: '#5894f4', symbol: '‚óØ' },
            fire: { color: '#ed1b43', symbol: '‚ô¶' },
            wind: { color: '#ffce00', symbol: '‚âã' },
            void: { color: '#9458f4', symbol: '‚ú∫' },
            catacomb: { color: '#8b4513', symbol: '‚ò†' }
        };

        // Spell System for pattern-based stone generation
        class SpellSystem {
            constructor() {
                this.SPELL_AP_COST = 2;
                
                // Per-player scroll inventories
                this.playerScrolls = []; // Array of { collected: Set, activated: Set }
                
                // Shared available scrolls pool
                this.availableScrolls = {
                    earth: new Set(['EARTH_SCROLL_1', 'EARTH_SCROLL_2', 'EARTH_SCROLL_3', 'EARTH_SCROLL_4', 'EARTH_SCROLL_5']),
                    water: new Set(['WATER_SCROLL_1', 'WATER_SCROLL_2', 'WATER_SCROLL_3', 'WATER_SCROLL_4', 'WATER_SCROLL_5']),
                    fire: new Set(['FIRE_SCROLL_1', 'FIRE_SCROLL_2', 'FIRE_SCROLL_3', 'FIRE_SCROLL_4', 'FIRE_SCROLL_5']),
                    wind: new Set(['WIND_SCROLL_1', 'WIND_SCROLL_2', 'WIND_SCROLL_3', 'WIND_SCROLL_4', 'WIND_SCROLL_5']),
                    void: new Set(['VOID_SCROLL_1', 'VOID_SCROLL_2', 'VOID_SCROLL_3', 'VOID_SCROLL_4', 'VOID_SCROLL_5']),
                    catacomb: new Set(['CATACOMB_SCROLL_1', 'CATACOMB_SCROLL_2', 'CATACOMB_SCROLL_3', 'CATACOMB_SCROLL_4', 'CATACOMB_SCROLL_5', 'CATACOMB_SCROLL_6', 'CATACOMB_SCROLL_7', 'CATACOMB_SCROLL_8', 'CATACOMB_SCROLL_9', 'CATACOMB_SCROLL_10'])
                };
                
                this.initializePatterns();
                this.updateScrollCount();
            }
            
            // Get active player's scroll collection
            // In multiplayer, show MY scrolls for display, but use activePlayerIndex for game logic
            getPlayerScrolls(forDisplay = false) {
                // For display in multiplayer, show my own scrolls
                const displayIndex = (forDisplay && isMultiplayer && myPlayerIndex !== null) ? myPlayerIndex : activePlayerIndex;

                if (!this.playerScrolls[displayIndex]) {
                    this.playerScrolls[displayIndex] = {
                        collected: new Set(),
                        activated: new Set()
                    };
                }
                return this.playerScrolls[displayIndex];
            }

            // Compatibility getters for existing code
            // These show the display scrolls (my scrolls in multiplayer)
            get collectedScrolls() {
                return this.getPlayerScrolls(true).collected;
            }

            get activatedScrollTypes() {
                return this.getPlayerScrolls(true).activated;
            }

            initializePatterns() {
                // Corrected patterns from user's visual editor
                const level1Patterns = [
                    [{ q: 0, r: -1 }, { q: 0, r: 1 }],
                    [{ q: 1, r: -1 }, { q: -1, r: 1 }],
                    [{ q: 1, r: 0 }, { q: -1, r: 0 }]
                ];

                const level2Patterns = [
                    [{ q: -1, r: -1 }, { q: 1, r: 1 }],
                    [{ q: 1, r: -2 }, { q: -1, r: 2 }],
                    [{ q: 2, r: -1 }, { q: -2, r: 1 }]
                ];

                const level3Patterns = [
                    [{ q: 1, r: -1 }, { q: -1, r: 0 }, { q: 0, r: 1 }],
                    [{ q: 0, r: -1 }, { q: 1, r: 0 }, { q: -1, r: 1 }]
                ];

                const level4Patterns = [
                    [{ q: 1, r: -2 }, { q: -2, r: 1 }, { q: 1, r: 1 }],
                    [{ q: -1, r: -1 }, { q: 2, r: -1 }, { q: -1, r: 2 }]
                ];

                const level5Patterns = [
                    [{ q: 0, r: -1 }, { q: 0, r: 1 }, { q: 2, r: -1 }, { q: -2, r: 1 }],
                    [{ q: 1, r: -1 }, { q: -1, r: 1 }, { q: -1, r: -1 }, { q: 1, r: 1 }],
                    [{ q: 1, r: 0 }, { q: -1, r: 0 }, { q: 1, r: -2 }, { q: -1, r: 2 }]
                ];

                this.patterns = {};
                const elementTypes = ['earth', 'water', 'fire', 'wind', 'void'];
                
                elementTypes.forEach(element => {
                    [level1Patterns, level2Patterns, level3Patterns, level4Patterns, level5Patterns].forEach((patterns, level) => {
                        const scrollName = `${element.toUpperCase()}_SCROLL_${level + 1}`;
                        this.patterns[scrollName] = {
                            name: `${element.charAt(0).toUpperCase() + element.slice(1)} Scroll ${toRoman(level + 1)}`,
                            description: `Stand in pattern to gain +${level + 1} ${element} stones (2 AP)`,
                            level: level + 1,
                            element: element,
                            patterns: patterns.map(pattern => 
                                pattern.map(pos => ({ ...pos, type: element }))
                            )
                        };
                    });
                });
                
                // Add catacomb scrolls (multi-element patterns)
                // Each gets 3 rotational variations like level 2 scrolls
                const catacombBase = {
                    CATACOMB_SCROLL_1: [
                        { q: -1, r: -1, type: "water" },
                        { q: 1, r: 1, type: "water" },
                        { q: 1, r: -2, type: "earth" },
                        { q: -1, r: 2, type: "earth" }
                    ],
                    CATACOMB_SCROLL_2: [
                        { q: -1, r: -1, type: "earth" },
                        { q: 1, r: 1, type: "earth" },
                        { q: 1, r: -2, type: "fire" },
                        { q: -1, r: 2, type: "fire" }
                    ],
                    CATACOMB_SCROLL_3: [
                        { q: -1, r: -1, type: "wind" },
                        { q: 1, r: 1, type: "wind" },
                        { q: 1, r: -2, type: "earth" },
                        { q: -1, r: 2, type: "earth" }
                    ],
                    CATACOMB_SCROLL_4: [
                        { q: -1, r: -1, type: "void" },
                        { q: 1, r: 1, type: "void" },
                        { q: 1, r: -2, type: "earth" },
                        { q: -1, r: 2, type: "earth" }
                    ],
                    CATACOMB_SCROLL_5: [
                        { q: -1, r: -1, type: "water" },
                        { q: 1, r: 1, type: "water" },
                        { q: 1, r: -2, type: "fire" },
                        { q: -1, r: 2, type: "fire" }
                    ],
                    CATACOMB_SCROLL_6: [
                        { q: -1, r: -1, type: "wind" },
                        { q: 1, r: 1, type: "wind" },
                        { q: 1, r: -2, type: "water" },
                        { q: -1, r: 2, type: "water" }
                    ],
                    CATACOMB_SCROLL_7: [
                        { q: -1, r: -1, type: "void" },
                        { q: 1, r: 1, type: "void" },
                        { q: 1, r: -2, type: "water" },
                        { q: -1, r: 2, type: "water" }
                    ],
                    CATACOMB_SCROLL_8: [
                        { q: -1, r: -1, type: "fire" },
                        { q: 1, r: 1, type: "fire" },
                        { q: 1, r: -2, type: "wind" },
                        { q: -1, r: 2, type: "wind" }
                    ],
                    CATACOMB_SCROLL_9: [
                        { q: -1, r: -1, type: "void" },
                        { q: 1, r: 1, type: "void" },
                        { q: 1, r: -2, type: "wind" },
                        { q: -1, r: 2, type: "wind" }
                    ],
                    CATACOMB_SCROLL_10: [
                        { q: -1, r: -1, type: "fire" },
                        { q: 1, r: 1, type: "fire" },
                        { q: 1, r: -2, type: "void" },
                        { q: -1, r: 2, type: "void" }
                    ]
                };
                
                // Generate 3 rotational variations for each catacomb scroll
                Object.entries(catacombBase).forEach(([scrollName, basePattern]) => {
                    const scrollNum = parseInt(scrollName.split('_')[2]);
                    
                    // Helper function to rotate hex coordinate by 60 degrees
                    const rotateHex = (q, r, steps) => {
                        // Rotate counter-clockwise by steps * 60 degrees
                        let nq = q, nr = r;
                        for (let i = 0; i < steps; i++) {
                            const tempQ = nq;
                            nq = -nr;
                            nr = -(-tempQ - nr);
                        }
                        return { q: nq, r: nr };
                    };
                    
                    // Create 3 rotational variations (0¬∞, 120¬∞, 240¬∞)
                    const variations = [
                        basePattern, // 0¬∞ rotation
                        basePattern.map(pos => ({ // 120¬∞ rotation (2 steps)
                            ...rotateHex(pos.q, pos.r, 2),
                            type: pos.type
                        })),
                        basePattern.map(pos => ({ // 240¬∞ rotation (4 steps)
                            ...rotateHex(pos.q, pos.r, 4),
                            type: pos.type
                        }))
                    ];
                    
                    this.patterns[scrollName] = {
                        name: `Catacomb Scroll ${scrollNum}`,
                        description: `Multi-element pattern: gain +2 of each stone type (2 AP)`,
                        level: 2,
                        element: 'catacomb',
                        patterns: variations
                    };
                });
            }

            onTileRevealed(shrineType) {
                if (shrineType === 'player') return null;
                if (!this.availableScrolls[shrineType] || this.availableScrolls[shrineType].size === 0) {
                    return null;
                }

                const available = Array.from(this.availableScrolls[shrineType]);
                const selected = available[Math.floor(Math.random() * available.length)];

                this.availableScrolls[shrineType].delete(selected);
                // Add to the ACTIVE player's collection (not display)
                this.getPlayerScrolls(false).collected.add(selected);
                this.updateScrollCount();

                // Broadcast scroll collection in multiplayer
                if (isMultiplayer) {
                    broadcastGameAction('scroll-collected', {
                        playerIndex: activePlayerIndex,
                        scrollName: selected,
                        shrineType: shrineType
                    });
                }

                const scrollInfo = this.patterns[selected];
                this.showScrollNotification(scrollInfo, shrineType);
                return scrollInfo;
            }

            showScrollNotification(scrollInfo, elementType) {
                const notification = document.createElement('div');
                Object.assign(notification.style, {
                    position: 'fixed', left: '50%', top: '50%',
                    transform: 'translate(-50%, -50%)',
                    backgroundColor: '#2c3e50', padding: '30px',
                    borderRadius: '10px', boxShadow: '0 0 20px rgba(0,0,0,0.5)',
                    zIndex: '1000', color: 'white', textAlign: 'center',
                    minWidth: '400px', maxWidth: '600px'
                });

                const title = document.createElement('h2');
                title.textContent = 'üìú New Scroll Discovered!';
                const stoneType = STONE_TYPES[elementType];
                title.style.color = stoneType ? stoneType.color : '#9458f4'; // Default to void purple
                title.style.margin = '0 0 20px 0';
                notification.appendChild(title);

                const name = document.createElement('div');
                name.textContent = scrollInfo.name;
                name.style.fontSize = '24px';
                name.style.fontWeight = 'bold';
                name.style.marginBottom = '15px';
                notification.appendChild(name);

                const desc = document.createElement('div');
                desc.textContent = scrollInfo.description;
                desc.style.fontSize = '16px';
                desc.style.color = '#bdc3c7';
                desc.style.marginBottom = '20px';
                notification.appendChild(desc);

                const closeBtn = document.createElement('button');
                closeBtn.textContent = 'Got it!';
                closeBtn.onclick = () => document.body.removeChild(notification);
                notification.appendChild(closeBtn);

                document.body.appendChild(notification);
            }

            checkPattern(patternName) {
                const pattern = this.patterns[patternName];
                if (!pattern || !playerPosition) return false;

                const playerHex = pixelToHex(playerPosition.x, playerPosition.y, TILE_SIZE);
                
                console.log(`  Checking ${patternName}...`);

                return pattern.patterns.some((patternVariant, variantIdx) => {
                    const allMatch = patternVariant.every((req, reqIdx) => {
                        const checkHex = hexToPixel(playerHex.q + req.q, playerHex.r + req.r, TILE_SIZE);
                        const stone = placedStones.find(s => {
                            const dist = Math.sqrt(Math.pow(s.x - checkHex.x, 2) + Math.pow(s.y - checkHex.y, 2));
                            const matches = dist < 5 && s.type === req.type;
                            if (matches) {
                                console.log(`    ‚úì Found ${s.type} stone at (${req.q}, ${req.r})`);
                            }
                            return matches;
                        });
                        if (!stone) {
                            console.log(`    ‚úó Missing ${req.type} stone at (${req.q}, ${req.r})`);
                        }
                        return !!stone;
                    });
                    
                    if (allMatch) {
                        console.log(`    ‚úì‚úì‚úì PATTERN VARIANT ${variantIdx + 1} MATCHED!`);
                    }
                    return allMatch;
                });
            }

            castSpell() {
                if (!canAfford(this.SPELL_AP_COST)) {
                    updateStatus(`Not enough AP! Need ${this.SPELL_AP_COST} AP to cast.`);
                    return false;
                }

                // Debug: Log player position and nearby stones
                console.log('üîÆ Attempting to cast spell...');
                console.log(`Player position: (${playerPosition.x.toFixed(1)}, ${playerPosition.y.toFixed(1)})`);
                
                if (playerPosition) {
                    const playerHex = pixelToHex(playerPosition.x, playerPosition.y, TILE_SIZE);
                    console.log(`Player hex: q=${playerHex.q}, r=${playerHex.r}`);
                    
                    // Log nearby stones
                    console.log('Nearby stones:');
                    const nearbyStones = [];
                    placedStones.forEach(stone => {
                        const stoneHex = pixelToHex(stone.x, stone.y, TILE_SIZE);
                        const relQ = stoneHex.q - playerHex.q;
                        const relR = stoneHex.r - playerHex.r;
                        nearbyStones.push({ type: stone.type, q: relQ, r: relR });
                        console.log(`  ${stone.type} at relative (${relQ}, ${relR})`);
                    });
                    
                    // Check each collected scroll and show why it doesn't match
                    console.log('\nChecking collected scrolls:');
                    for (const scrollName of this.collectedScrolls) {
                        const pattern = this.patterns[scrollName];
                        console.log(`\n${scrollName} requires:`);
                        pattern.patterns.forEach((patternVariant, idx) => {
                            const coords = patternVariant.map(p => `(${p.q},${p.r}) ${p.type}`).join(' + ');
                            const matches = patternVariant.every(req => {
                                return nearbyStones.some(s => s.q === req.q && s.r === req.r && s.type === req.type);
                            });
                            console.log(`  Pattern ${idx + 1}: ${coords} - ${matches ? '‚úì MATCH' : '‚úó no match'}`);
                        });
                    }
                }

                const matchingSpells = [];
                for (const scrollName of this.collectedScrolls) {
                    if (this.checkPattern(scrollName)) {
                        console.log(`\n‚úì Pattern match found: ${scrollName}`);
                        matchingSpells.push({ name: scrollName, spell: this.patterns[scrollName] });
                    }
                }

                if (matchingSpells.length === 0) {
                    updateStatus("No valid spell pattern found! Check console for details.");
                    console.log('\n‚úó No matching patterns');
                    return false;
                }

                matchingSpells.sort((a, b) => b.spell.level - a.spell.level);

                if (matchingSpells.length > 1) {
                    this.showSpellSelection(matchingSpells);
                } else {
                    this.executeSpell(matchingSpells[0]);
                }
                return true;
            }

            showSpellSelection(spells) {
                const popup = document.createElement('div');
                Object.assign(popup.style, {
                    position: 'fixed', left: '50%', top: '50%',
                    transform: 'translate(-50%, -50%)',
                    backgroundColor: '#2c3e50', padding: '20px',
                    borderRadius: '10px', boxShadow: '0 0 10px rgba(0,0,0,0.5)',
                    zIndex: '1000', color: 'white', minWidth: '300px'
                });

                const title = document.createElement('h3');
                title.textContent = 'Select Scroll to Cast';
                title.style.textAlign = 'center';
                popup.appendChild(title);

                spells.forEach(({name, spell}) => {
                    const btn = document.createElement('button');
                    btn.textContent = `${spell.name} (+${spell.level} ${spell.element})`;
                    btn.style.width = '100%';
                    btn.style.marginBottom = '10px';
                    btn.onclick = () => {
                        document.body.removeChild(popup);
                        this.executeSpell({name, spell});
                    };
                    popup.appendChild(btn);
                });

                document.body.appendChild(popup);
            }

            executeSpell({name, spell}) {
                spendAP(this.SPELL_AP_COST); // Use void AP first, then regular AP

                if (spell.element === 'catacomb') {
                    // Catacomb scrolls give +2 of each element type in the pattern
                    const elementCounts = {};
                    spell.patterns[0].forEach(pos => {
                        elementCounts[pos.type] = (elementCounts[pos.type] || 0) + 1;
                    });
                    
                    const rewards = [];
                    Object.entries(elementCounts).forEach(([element, count]) => {
                        playerPool[element] = Math.min(
                            playerPoolCapacity[element],
                            playerPool[element] + count
                        );
                        updateStoneCount(element);

                        // Track activated element for win condition (for active player)
                        this.getPlayerScrolls(false).activated.add(element);
                        rewards.push(`+${count} ${element}`);
                    });
                    
                    updatePlayerElementSymbols(activePlayerIndex);
                    updateStatus(`‚ú® Catacomb spell cast! Added ${rewards.join(', ')} stones!`);
                } else {
                    // Regular element scrolls
                    playerPool[spell.element] = Math.min(
                        playerPoolCapacity[spell.element],
                        playerPool[spell.element] + spell.level
                    );
                    updateStoneCount(spell.element);

                    // Track activated element for win condition (for active player)
                    this.getPlayerScrolls(false).activated.add(spell.element);
                    updatePlayerElementSymbols(activePlayerIndex);
                    updateStatus(`‚ú® Spell cast! Added +${spell.level} ${spell.element} stones!`);
                }

                // Broadcast spell cast in multiplayer
                if (isMultiplayer) {
                    if (spell.element === 'catacomb') {
                        const elementCounts = {};
                        spell.patterns[0].forEach(pos => {
                            elementCounts[pos.type] = (elementCounts[pos.type] || 0) + 1;
                        });
                        broadcastGameAction('spell-cast', {
                            playerIndex: activePlayerIndex,
                            spellName: name,
                            elements: Object.keys(elementCounts), // Array of elements activated
                            isCatacomb: true
                        });
                    } else {
                        broadcastGameAction('spell-cast', {
                            playerIndex: activePlayerIndex,
                            spellName: name,
                            element: spell.element,
                            level: spell.level,
                            isCatacomb: false
                        });
                    }

                    // Sync resources after spell adds stones
                    syncPlayerState();
                }

                // Check if THIS player has won (activated all 5 elements)
                if (this.getPlayerScrolls(false).activated.size === 5) {
                    this.showLevelComplete(activePlayerIndex);

                    // In multiplayer, mark game as finished in database
                    if (isMultiplayer) {
                        handleGameOver(activePlayerIndex);
                    }
                }
            }

            showLevelComplete(playerIndex) {
                const notification = document.createElement('div');
                Object.assign(notification.style, {
                    position: 'fixed', left: '50%', top: '50%',
                    transform: 'translate(-50%, -50%)',
                    backgroundColor: '#2c3e50', padding: '40px',
                    borderRadius: '15px', boxShadow: '0 0 30px rgba(0,0,0,0.8)',
                    zIndex: '1000', color: 'white', textAlign: 'center', minWidth: '500px',
                    border: '3px solid gold'
                });

                const title = document.createElement('h1');
                title.textContent = 'üéâ VICTORY! üéâ';
                title.style.marginTop = '0';
                title.style.color = 'gold';
                title.style.fontSize = '42px';
                title.style.textShadow = '2px 2px 4px rgba(0,0,0,0.5)';
                notification.appendChild(title);

                // Show which player won
                const playerColor = playerPositions[playerIndex]?.color;
                const colorNames = {
                    '#9458f4': 'Purple (Void)',
                    '#ffce00': 'Yellow (Wind)',
                    '#ed1b43': 'Red (Fire)',
                    '#5894f4': 'Blue (Water)',
                    '#69d83a': 'Green (Earth)'
                };
                
                const playerName = document.createElement('div');
                playerName.textContent = `${colorNames[playerColor] || 'Player ' + (playerIndex + 1)} wins!`;
                playerName.style.fontSize = '28px';
                playerName.style.fontWeight = 'bold';
                playerName.style.color = playerColor || 'gold';
                playerName.style.marginBottom = '10px';
                notification.appendChild(playerName);

                const msg = document.createElement('div');
                msg.textContent = 'You have mastered all five elements!';
                msg.style.fontSize = '24px';
                msg.style.marginBottom = '10px';
                notification.appendChild(msg);

                const elements = document.createElement('div');
                elements.style.fontSize = '32px';
                elements.style.margin = '20px 0';
                elements.innerHTML = '‚ñ≤ ‚óØ ‚ô¶ ‚âã ‚ú∫';
                notification.appendChild(elements);

                const subtitle = document.createElement('div');
                subtitle.textContent = 'The path of balance is complete.';
                subtitle.style.fontSize = '16px';
                subtitle.style.fontStyle = 'italic';
                subtitle.style.color = '#bdc3c7';
                subtitle.style.marginBottom = '20px';
                notification.appendChild(subtitle);

                const buttonContainer = document.createElement('div');
                buttonContainer.style.display = 'flex';
                buttonContainer.style.gap = '10px';
                buttonContainer.style.justifyContent = 'center';

                if (isMultiplayer) {
                    const lobbyBtn = document.createElement('button');
                    lobbyBtn.textContent = 'Return to Lobby';
                    lobbyBtn.style.padding = '12px 24px';
                    lobbyBtn.style.fontSize = '16px';
                    lobbyBtn.style.backgroundColor = 'gold';
                    lobbyBtn.style.color = '#2c3e50';
                    lobbyBtn.style.border = 'none';
                    lobbyBtn.style.borderRadius = '5px';
                    lobbyBtn.style.cursor = 'pointer';
                    lobbyBtn.style.fontWeight = 'bold';
                    lobbyBtn.onclick = () => {
                        window.location.reload(); // Reload to return to lobby
                    };
                    buttonContainer.appendChild(lobbyBtn);
                } else {
                    const closeBtn = document.createElement('button');
                    closeBtn.textContent = 'Continue Playing';
                    closeBtn.style.padding = '12px 24px';
                    closeBtn.style.fontSize = '16px';
                    closeBtn.style.backgroundColor = 'gold';
                    closeBtn.style.color = '#2c3e50';
                    closeBtn.style.border = 'none';
                    closeBtn.style.borderRadius = '5px';
                    closeBtn.style.cursor = 'pointer';
                    closeBtn.style.fontWeight = 'bold';
                    closeBtn.onclick = () => document.body.removeChild(notification);
                    buttonContainer.appendChild(closeBtn);
                }

                notification.appendChild(buttonContainer);
                document.body.appendChild(notification);
            }

            createPatternVisual(scroll, elementType) {
                const container = document.createElement('div');
                container.style.display = 'flex';
                container.style.justifyContent = 'center';
                container.style.alignItems = 'center';
                container.style.padding = '15px';
                container.style.backgroundColor = '#2c3e50';
                container.style.borderRadius = '5px';
                container.style.marginTop = '10px';
                container.style.position = 'relative';

                // Create SVG
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '200');
                svg.setAttribute('height', '200');
                svg.setAttribute('viewBox', '-100 -100 200 200');

                const hexSize = 15;

                // Helper to create hex points
                const createHexPoints = (cx, cy, size) => {
                    const points = [];
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i - Math.PI / 6;
                        points.push(`${cx + size * Math.cos(angle)},${cy + size * Math.sin(angle)}`);
                    }
                    return points.join(' ');
                };

                // Helper to convert axial to pixel
                const axialToPixel = (q, r) => {
                    const x = hexSize * (Math.sqrt(3) * q + Math.sqrt(3)/2 * r);
                    const y = hexSize * (3/2 * r);
                    return { x, y };
                };

                // Draw background hexes in a grid (static layer)
                const backgroundGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                for (let q = -2; q <= 2; q++) {
                    for (let r = -2; r <= 2; r++) {
                        if (Math.abs(q + r) <= 2) {
                            const pos = axialToPixel(q, r);
                            const hex = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                            hex.setAttribute('points', createHexPoints(pos.x, pos.y, hexSize));
                            hex.setAttribute('fill', '#34495e');
                            hex.setAttribute('stroke', '#2c3e50');
                            hex.setAttribute('stroke-width', '2');
                            backgroundGroup.appendChild(hex);
                        }
                    }
                }
                svg.appendChild(backgroundGroup);

                // Draw player hex (static layer)
                const playerHex = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                playerHex.setAttribute('cx', '0');
                playerHex.setAttribute('cy', '0');
                playerHex.setAttribute('r', hexSize * 0.5);
                playerHex.setAttribute('fill', '#fff');
                playerHex.setAttribute('stroke', '#333');
                playerHex.setAttribute('stroke-width', '2');
                svg.appendChild(playerHex);

                // Create pattern groups for each variation (animated layers)
                const patternGroups = [];
                scroll.patterns.forEach((patternVariation, idx) => {
                    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    group.style.opacity = idx === 0 ? '1' : '0';
                    group.style.transition = 'opacity 0.5s ease-in-out';

                    patternVariation.forEach(pos => {
                        const pixelPos = axialToPixel(pos.q, pos.r);
                        const stoneHex = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        stoneHex.setAttribute('points', createHexPoints(pixelPos.x, pixelPos.y, hexSize));
                        // Use pos.type if available (for catacomb multi-element), otherwise use elementType
                        const stoneType = pos.type || elementType;
                        stoneHex.setAttribute('fill', STONE_TYPES[stoneType].color);
                        stoneHex.setAttribute('stroke', '#fff');
                        stoneHex.setAttribute('stroke-width', '2');
                        group.appendChild(stoneHex);

                        // Add symbol
                        const symbol = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        symbol.setAttribute('x', pixelPos.x);
                        symbol.setAttribute('y', pixelPos.y);
                        symbol.setAttribute('text-anchor', 'middle');
                        symbol.setAttribute('dominant-baseline', 'middle');
                        symbol.setAttribute('fill', '#fff');
                        symbol.setAttribute('font-size', '12');
                        symbol.setAttribute('font-weight', 'bold');
                        symbol.textContent = STONE_TYPES[stoneType].symbol;
                        group.appendChild(symbol);
                    });

                    patternGroups.push(group);
                    svg.appendChild(group);
                });

                // Add pattern indicator text
                const indicatorText = document.createElement('div');
                indicatorText.style.position = 'absolute';
                indicatorText.style.bottom = '5px';
                indicatorText.style.right = '10px';
                indicatorText.style.fontSize = '11px';
                indicatorText.style.color = '#95a5a6';
                indicatorText.style.fontStyle = 'italic';
                indicatorText.textContent = `Pattern 1/${patternGroups.length}`;
                container.appendChild(indicatorText);

                // Cycle through patterns
                let currentPatternIdx = 0;
                const cycleInterval = setInterval(() => {
                    // Fade out current
                    patternGroups[currentPatternIdx].style.opacity = '0';
                    
                    // Move to next
                    currentPatternIdx = (currentPatternIdx + 1) % patternGroups.length;
                    
                    // Fade in next
                    patternGroups[currentPatternIdx].style.opacity = '1';
                    
                    // Update indicator
                    indicatorText.textContent = `Pattern ${currentPatternIdx + 1}/${patternGroups.length}`;
                }, 2500); // Change pattern every 2.5 seconds

                // Store interval ID so we can clean it up if needed
                container.dataset.intervalId = cycleInterval;

                container.appendChild(svg);
                return container;
            }

            showInventory() {
                const popup = document.createElement('div');
                Object.assign(popup.style, {
                    position: 'fixed', left: '50%', top: '50%',
                    transform: 'translate(-50%, -50%)',
                    backgroundColor: '#2c3e50', padding: '20px',
                    borderRadius: '10px', boxShadow: '0 0 20px rgba(0,0,0,0.5)',
                    zIndex: '1001', minWidth: '400px', maxHeight: '80vh',
                    overflowY: 'auto', color: 'white'
                });

                const title = document.createElement('h2');
                title.textContent = 'üìú Scroll Collection';
                title.style.textAlign = 'center';
                title.style.color = '#3498db';
                popup.appendChild(title);

                const closeBtn = document.createElement('button');
                closeBtn.textContent = '√ó';
                Object.assign(closeBtn.style, {
                    position: 'absolute', right: '10px', top: '10px',
                    background: 'transparent', border: 'none',
                    color: 'white', fontSize: '24px', cursor: 'pointer'
                });
                closeBtn.onclick = () => document.body.removeChild(popup);
                popup.appendChild(closeBtn);

                const elementTypes = ['earth', 'water', 'fire', 'wind', 'void'];
                elementTypes.forEach(element => {
                    const scrolls = Array.from(this.collectedScrolls)
                        .filter(s => s.startsWith(element.toUpperCase()))
                        .map(s => this.patterns[s]);

                    if (scrolls.length > 0) {
                        const section = document.createElement('div');
                        section.style.marginBottom = '20px';

                        const header = document.createElement('h3');
                        header.textContent = `${STONE_TYPES[element].symbol} ${element.charAt(0).toUpperCase() + element.slice(1)} Scrolls`;
                        header.style.color = STONE_TYPES[element].color;
                        header.style.borderBottom = `2px solid ${STONE_TYPES[element].color}`;
                        section.appendChild(header);

                        scrolls.forEach(scroll => {
                            const scrollDiv = document.createElement('div');
                            scrollDiv.style.backgroundColor = '#34495e';
                            scrollDiv.style.padding = '15px';
                            scrollDiv.style.marginBottom = '10px';
                            scrollDiv.style.borderRadius = '5px';

                            const scrollName = document.createElement('div');
                            scrollName.textContent = scroll.name;
                            scrollName.style.fontWeight = 'bold';
                            scrollName.style.marginBottom = '5px';
                            scrollDiv.appendChild(scrollName);

                            const scrollDesc = document.createElement('div');
                            scrollDesc.textContent = scroll.description;
                            scrollDesc.style.fontSize = '14px';
                            scrollDesc.style.color = '#bdc3c7';
                            scrollDesc.style.marginBottom = '10px';
                            scrollDiv.appendChild(scrollDesc);

                            // Add visual hex pattern display
                            const patternVisual = this.createPatternVisual(scroll, element);
                            scrollDiv.appendChild(patternVisual);

                            // Add pattern visualization
                            const patternInfo = document.createElement('div');
                            patternInfo.style.fontSize = '12px';
                            patternInfo.style.color = '#95a5a6';
                            patternInfo.style.fontFamily = 'monospace';
                            patternInfo.style.backgroundColor = '#2c3e50';
                            patternInfo.style.padding = '10px';
                            patternInfo.style.borderRadius = '5px';
                            patternInfo.style.marginTop = '10px';
                            
                            const patternTitle = document.createElement('div');
                            patternTitle.textContent = 'Required Pattern (one of these):';
                            patternTitle.style.marginBottom = '5px';
                            patternInfo.appendChild(patternTitle);
                            
                            // Show first 3 pattern variations
                            scroll.patterns.slice(0, 3).forEach((pattern, idx) => {
                                const patternLine = document.createElement('div');
                                const coords = pattern.map(pos => `(${pos.q},${pos.r})`).join(' + ');
                                patternLine.textContent = `${idx + 1}. Stones at: ${coords}`;
                                patternLine.style.marginLeft = '10px';
                                patternLine.style.marginTop = '3px';
                                patternInfo.appendChild(patternLine);
                            });
                            
                            if (scroll.patterns.length > 3) {
                                const moreText = document.createElement('div');
                                moreText.textContent = `... and ${scroll.patterns.length - 3} more rotations`;
                                moreText.style.marginLeft = '10px';
                                moreText.style.marginTop = '3px';
                                moreText.style.fontStyle = 'italic';
                                patternInfo.appendChild(moreText);
                            }
                            
                            scrollDiv.appendChild(patternInfo);

                            section.appendChild(scrollDiv);
                        });

                        popup.appendChild(section);
                    }
                });

                // Add catacomb scrolls section
                const catacombScrolls = Array.from(this.collectedScrolls)
                    .filter(s => s.startsWith('CATACOMB'))
                    .map(s => this.patterns[s]);

                if (catacombScrolls.length > 0) {
                    const section = document.createElement('div');
                    section.style.marginBottom = '20px';

                    const header = document.createElement('h3');
                    header.textContent = '‚ö∞Ô∏è Catacomb Scrolls (Multi-Element)';
                    header.style.color = '#9b59b6';
                    header.style.borderBottom = '2px solid #9b59b6';
                    section.appendChild(header);

                    catacombScrolls.forEach(scroll => {
                        const scrollDiv = document.createElement('div');
                        scrollDiv.style.backgroundColor = '#34495e';
                        scrollDiv.style.padding = '15px';
                        scrollDiv.style.marginBottom = '10px';
                        scrollDiv.style.borderRadius = '5px';

                        const scrollName = document.createElement('div');
                        scrollName.textContent = scroll.name;
                        scrollName.style.fontWeight = 'bold';
                        scrollName.style.marginBottom = '5px';
                        scrollDiv.appendChild(scrollName);

                        const scrollDesc = document.createElement('div');
                        scrollDesc.textContent = scroll.description;
                        scrollDesc.style.fontSize = '14px';
                        scrollDesc.style.color = '#bdc3c7';
                        scrollDesc.style.marginBottom = '10px';
                        scrollDiv.appendChild(scrollDesc);

                        // Add visual hex pattern display (catacomb uses 'catacomb' as element type)
                        const patternVisual = this.createPatternVisual(scroll, 'catacomb');
                        scrollDiv.appendChild(patternVisual);

                        // Add pattern visualization
                        const patternInfo = document.createElement('div');
                        patternInfo.style.fontSize = '12px';
                        patternInfo.style.color = '#95a5a6';
                        patternInfo.style.fontFamily = 'monospace';
                        patternInfo.style.backgroundColor = '#2c3e50';
                        patternInfo.style.padding = '10px';
                        patternInfo.style.borderRadius = '5px';
                        patternInfo.style.marginTop = '10px';
                        
                        const patternTitle = document.createElement('div');
                        patternTitle.textContent = 'Required Pattern (one of these):';
                        patternTitle.style.marginBottom = '5px';
                        patternInfo.appendChild(patternTitle);
                        
                        // Show all 3 pattern variations
                        scroll.patterns.forEach((pattern, idx) => {
                            const patternLine = document.createElement('div');
                            const coords = pattern.map(pos => `${pos.type.charAt(0).toUpperCase()}(${pos.q},${pos.r})`).join(' + ');
                            patternLine.textContent = `${idx + 1}. Stones at: ${coords}`;
                            patternLine.style.marginLeft = '10px';
                            patternLine.style.marginTop = '3px';
                            patternInfo.appendChild(patternLine);
                        });
                        
                        scrollDiv.appendChild(patternInfo);
                        section.appendChild(scrollDiv);
                    });

                    popup.appendChild(section);
                }

                if (this.collectedScrolls.size === 0) {
                    const noScrolls = document.createElement('div');
                    noScrolls.textContent = 'No scrolls collected yet. Reveal tiles to find scrolls!';
                    noScrolls.style.textAlign = 'center';
                    noScrolls.style.color = '#bdc3c7';
                    noScrolls.style.padding = '20px';
                    popup.appendChild(noScrolls);
                }

                document.body.appendChild(popup);
            }

            updateScrollCount() {
                document.getElementById('scroll-count').textContent = this.collectedScrolls.size;
            }
        }

        function toRoman(num) {
            const map = { 1: 'I', 2: 'II', 3: 'III', 4: 'IV', 5: 'V' };
            return map[num] || num;
        }

        // Core game state - declare these FIRST
        let placedTiles = [];
        let placedStones = [];
        let playerPositions = []; // Array of {x, y, element, color} for each player
        let activePlayerIndex = 0; // Which player is currently active
        
        // Player pools - one per player
        let playerPools = []; // Each entry is { earth: 0, water: 0, fire: 0, wind: 0, void: 0 }
        const playerPoolCapacity = { earth: 5, water: 5, fire: 5, wind: 5, void: 5 };

        // Elemental source pool - stones available from shrines (max 25 each)
        const sourcePool = { earth: 20, water: 20, fire: 20, wind: 20, void: 20 };
        const sourcePoolCapacity = { earth: 25, water: 25, fire: 25, wind: 25, void: 25 };

        // Initialize spell system (after activePlayerIndex is defined)
        const spellSystem = new SpellSystem();

        // Compatibility: playerPool and stoneCounts refer to active player's pool
        // In multiplayer, playerPool shows MY pool (for display), but operations use activePlayerIndex
        Object.defineProperty(window, 'playerPool', {
            get() {
                // In multiplayer, show my own pool in the UI
                const displayIndex = (isMultiplayer && myPlayerIndex !== null) ? myPlayerIndex : activePlayerIndex;
                if (!playerPools[displayIndex]) {
                    playerPools[displayIndex] = { earth: 0, water: 0, fire: 0, wind: 0, void: 0 };
                }
                return playerPools[displayIndex];
            }
        });
        Object.defineProperty(window, 'stoneCounts', {
            get() {
                // In multiplayer, show my own pool in the UI
                const displayIndex = (isMultiplayer && myPlayerIndex !== null) ? myPlayerIndex : activePlayerIndex;
                if (!playerPools[displayIndex]) {
                    playerPools[displayIndex] = { earth: 0, water: 0, fire: 0, wind: 0, void: 0 };
                }
                return playerPools[displayIndex];
            }
        });
        const stoneCapacity = playerPoolCapacity;

        const boardSvg = document.getElementById('boardSvg');
        // Improve mobile interactions: prevent browser gestures from stealing touches
        boardSvg.style.touchAction = 'none';
        const viewport = document.getElementById('viewport');
        const deckTileSvg = document.getElementById('deckTile');
        const snapIndicator = document.getElementById('snapIndicator');
        
        // Compatibility: make playerPosition work as before for active player
        Object.defineProperty(window, 'playerPosition', {
            get() { return playerPositions[activePlayerIndex] || null; },
            set(val) { 
                if (val === null) {
                    playerPositions = [];
                    activePlayerIndex = 0;
                }
            }
        });
        
        let playerColor = null; // Current player's color (when placing their tile)
        let gameSessionColors = new Set(); // Colors used in the current game
        let currentAP = 5;
        let voidAP = 0; // Bonus AP from void stones (used first)
        let lastMove = null; // Stores { prevPos: {x, y}, newPos: {x, y}, apCost: number }

        // Track each player's AP for multiplayer display
        let playerAPs = []; // Each entry is { currentAP: 5, voidAP: 0 }

        // Track player activity for timeout/kick system
        let playerLastActivity = {}; // { playerId: timestamp }
        let activityCheckInterval = null;
        let gameInactivityTimeout = 120000;
        // Turn timer settings (reuses gameInactivityTimeout as the turn time limit, in ms)
        let kickOnTurnTimeout = true;
        let turnStartedAtMs = Date.now();
        let turnTimeoutInterval = null;
 // Default 2 minutes in milliseconds (set by host)
        let myLastActivity = Date.now(); // Track my own activity
        let timerDisplayInterval = null;

        const PLAYER_COLORS = {
            green: '#69d83a',
            blue: '#5894f4',
            red: '#ed1b43',
            yellow: '#ffce00',
            purple: '#9458f4'
        };

        // Mobile detection and touch support
        let isMobile = false;
        let mobileUIInitialized = false;
        function computeIsMobile() {
            return (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
                || window.matchMedia('(max-width: 768px)').matches
                || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0)
                || window.matchMedia('(pointer: coarse)').matches);
        }
        function updateIsMobile() {
            const next = computeIsMobile();
            if (next === isMobile && mobileUIInitialized) return;
            isMobile = next;

            // Initialize mobile UI once when we enter mobile mode
            if (isMobile && !mobileUIInitialized) {
                initializeMobileUI();
                mobileUIInitialized = true;
            }

            // Keep mobile decks in sync if mobile is active
            if (isMobile) {
                syncMobileTileDeck();
                syncMobileStoneDeck();
            }
        }

        // Touch state for gestures
        let touchStartTime = 0;
        let touchStartPos = { x: 0, y: 0 };
        let initialTouches = [];
        let initialRotation = 0;
        let isGestureRotating = false;
        let isPinching = false;
        let pinchStartDist = 0;
        let pinchStartScale = 1;
        let pinchStartMid = { x: 0, y: 0 };
        let pinchLastMid = { x: 0, y: 0 };
        let stoneLongPressTimer = null; // for long-press stone break on mobile

        // Helper function to get event coordinates (works for both mouse and touch)
        function getEventCoords(e) {
            if (e.touches && e.touches.length > 0) {
                return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
            return { x: e.clientX, y: e.clientY };
        }

        // Calculate angle between two touch points
        function getTouchAngle(touch1, touch2) {
            const dx = touch2.clientX - touch1.clientX;
            const dy = touch2.clientY - touch1.clientY;
            return Math.atan2(dy, dx) * (180 / Math.PI);
        }

        // Snap angle to nearest 60 degrees (6 positions for hexagon)
        function snapToHexRotation(degrees) {
            const step = 60;
            return Math.round(degrees / step) % 6;
        }

        function updateVoidAP() {
            // Void AP always equals current void stones
            const oldVoidAP = voidAP;
            voidAP = playerPool.void;
            console.log(`üîÑ updateVoidAP: ${oldVoidAP} ‚Üí ${voidAP} (playerPool.void=${playerPool.void})`);
            const display = document.getElementById('void-ap-display');
            if (voidAP > 0) {
                display.textContent = `(+${voidAP} ‚ú® Void AP)`;
                display.style.display = 'inline';
            } else {
                display.style.display = 'none';
            }
        }

        function getTotalAP() {
            return currentAP + voidAP;
        }

        function spendAP(cost) {
            console.log(`üí∞ spendAP called: cost=${cost}, before: voidAP=${voidAP}, currentAP=${currentAP}`);
            // Spend void AP first, then regular AP
            if (voidAP >= cost) {
                voidAP -= cost;
            } else {
                const remainingCost = cost - voidAP;
                voidAP = 0;
                currentAP -= remainingCost;
            }
            console.log(`üí∞ spendAP after: voidAP=${voidAP}, currentAP=${currentAP}, total=${getTotalAP()}`);
            document.getElementById('ap-count').textContent = currentAP;
            updateVoidAP();

            // Sync AP state in multiplayer
            syncPlayerState();
        }

        function canAfford(cost) {
            return getTotalAP() >= cost;
        }

        function attemptBreakStone(stoneId) {
            const stone = placedStones.find(s => s.id === stoneId);
            if (!stone) {
                console.log('‚ùå Stone not found');
                return;
            }

            console.log(`üí• attemptBreakStone called for stone id=${stoneId}, type=${stone.type}, position=(${stone.x.toFixed(1)}, ${stone.y.toFixed(1)})`);

            // Check if stone is adjacent to player
            if (!playerPosition) {
                updateStatus('‚ùå No player on board!');
                console.log('‚ùå No player on board!');
                return;
            }

            const isAdj = isAdjacentToPlayer(stone.x, stone.y);
            console.log(`üí• Adjacency check: ${isAdj}`);
            
            if (!isAdj) {
                updateStatus('‚ùå Stone must be adjacent to player to break!');
                console.log('‚ùå Stone must be adjacent to player to break!');
                return;
            }

            // Calculate break cost based on stone rank
            const STONE_RANK = {
                'void': 1,
                'wind': 2,
                'fire': 3,
                'water': 4,
                'earth': 5
            };

            const breakCost = STONE_RANK[stone.type];

            if (!canAfford(breakCost)) {
                updateStatus(`‚ùå Not enough AP! Need ${breakCost} AP to break ${stone.type} stone (have ${getTotalAP()} AP)`);
                return;
            }

            // Break the stone
            spendAP(breakCost);

            // Broadcast stone break to other players
            if (isMultiplayer) {
                broadcastGameAction('stone-break', {
                    stoneId: stoneId
                });
            }

            // Remove stone from board
            const stoneElement = stone.element;
            if (stoneElement && stoneElement.parentNode) {
                stoneElement.remove();
            }

            // Remove from placedStones array
            const index = placedStones.findIndex(s => s.id === stoneId);
            if (index !== -1) {
                placedStones.splice(index, 1);
            }

            // Return stone to source pool
            returnStoneToPool(stone.type);

            // Update interactions since a stone was removed
            updateTileClasses();
            recheckAllStoneInteractions();
            updateAllWaterStoneVisuals();
            updateAllVoidNullificationVisuals();

            updateStatus(`üí• Broke ${stone.type} stone! Cost: ${breakCost} AP (${getTotalAP()} AP remaining)`);
            console.log(`üí• Broke ${stone.type} stone (id=${stoneId}), cost=${breakCost} AP`);
        }

        let isDraggingTile = false;
        let isDraggingStone = false;
        let draggedTileId = null;
        let draggedTileRotation = 0;
        let draggedTileFlipped = false;
        let draggedTileShrineType = null;
        let draggedTileOriginalPos = null; // Store original position for snap-back
        let draggedStoneId = null;
        let draggedStoneType = null;
        let ghostTile = null;
        let ghostStone = null;
        let currentRotation = 0;
        let currentFlipped = true; // Start with tiles hidden (flipped)


        // Tile deck - 4 of each shrine type (24 tiles total for 1 player)
        let tileDeck = [];
        let deckIndex = 0;

        // Player tile deck
        let playerTilesAvailable = 0;
        let playerTileElements = [];

        function initializeDeck(numPlayers = 1) {
            const shrineTypes = ['earth', 'water', 'fire', 'wind', 'void', 'catacomb'];
            const tilesPerType = numPlayers; // 1 of each type per player

            tileDeck = [];

            shrineTypes.forEach(type => {
                for (let i = 0; i < tilesPerType; i++) {
                    tileDeck.push(type);
                }
            });

            // Shuffle the deck
            for (let i = tileDeck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [tileDeck[i], tileDeck[j]] = [tileDeck[j], tileDeck[i]];
            }

            deckIndex = 0;
        }

        function drawNextTileFromDeck() {
            if (deckIndex >= tileDeck.length) {
                updateStatus('No more tiles in deck!');
                return null;
            }
            const shrineType = tileDeck[deckIndex];
            deckIndex++;
            document.getElementById('deck-count').textContent = `${deckIndex}/${tileDeck.length}`;
            updateStatus(`Drew ${shrineType} tile (${deckIndex}/${tileDeck.length} used)`);
            return shrineType;
        }

        let viewportX = 0;
        let viewportY = 0;
        let viewportScale = 1;
        let viewportRotation = 0;
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;
        let lastPanX = 0;
        let lastPanY = 0;
        let isRotatingBoard = false;
        let rotateStartX = 0;
        let rotateStartRotation = 0;
        let isRotatingTile = false;
        let rotateTileStartX = 0;
        let rotateTileStartRotation = 0;
        let leftButtonDown = false;
        let rightButtonDown = false;

        function updateViewport() {
            const centerX = boardSvg.width.baseVal.value / 2;
            const centerY = boardSvg.height.baseVal.value / 2;
            viewport.setAttribute('transform',
                `translate(${centerX}, ${centerY}) rotate(${viewportRotation}) translate(${viewportX - centerX}, ${viewportY - centerY}) scale(${viewportScale})`);
        }

        function screenToWorld(screenX, screenY) {
            const centerX = boardSvg.width.baseVal.value / 2;
            const centerY = boardSvg.height.baseVal.value / 2;
            let x = screenX - centerX;
            let y = screenY - centerY;
            const rad = -viewportRotation * Math.PI / 180;
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);
            const rotatedX = x * cos - y * sin;
            const rotatedY = x * sin + y * cos;
            const scaledX = rotatedX / viewportScale;
            const scaledY = rotatedY / viewportScale;
            const worldX = scaledX - (viewportX - centerX) / viewportScale;
            const worldY = scaledY - (viewportY - centerY) / viewportScale;
            return { x: worldX, y: worldY };
        }

        function hexToPixel(q, r, s) {
            const width = s * Math.sqrt(3);
            const height = 2 * s;
            const x = width * (q + r / 2);
            const y = height * (3/4) * r;
            return { x, y };
        }

        function pixelToHex(x, y, s) {
            const q = (x * Math.sqrt(3)/3 - y / 3) / s;
            const r = (y * 2/3) / s;
            return hexRound(q, r);
        }

        function hexRound(q, r) {
            let s = -q - r;
            let rq = Math.round(q);
            let rr = Math.round(r);
            let rs = Math.round(s);
            const qDiff = Math.abs(rq - q);
            const rDiff = Math.abs(rr - r);
            const sDiff = Math.abs(rs - s);
            if (qDiff > rDiff && qDiff > sDiff) rq = -rr - rs;
            else if (rDiff > sDiff) rr = -rq - rs;
            return { q: rq, r: rr };
        }

        function createHexagonPoints(cx, cy, s) {
            const points = [];
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i - Math.PI / 6;
                const x = cx + s * Math.cos(angle);
                const y = cy + s * Math.sin(angle);
                points.push(`${x},${y}`);
            }
            return points.join(' ');
        }

        function createTrapezoidPoints(cx, cy, s, direction) {
            const hexVertices = [];
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i - Math.PI / 6;
                hexVertices.push({
                    x: cx + s * Math.cos(angle),
                    y: cy + s * Math.sin(angle)
                });
            }
            const indices = [
                [1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 0],
                [4, 5, 0, 1], [5, 0, 1, 2], [0, 1, 2, 3]
            ][direction];
            return indices.map(idx => `${hexVertices[idx].x},${hexVertices[idx].y}`).join(' ');
        }

        function createTileGroup(s, rotation = 0, flipped = false) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('transform', `rotate(${rotation * 60})`);

            if (flipped) {
                // Flipped side: only outer ring of hexagons + trapezoids (no center, no inner ring)
                const hexagons = [
                    { q: 2, r: -1 }, { q: 1, r: 1 }, { q: -1, r: 2 },
                    { q: -2, r: 1 }, { q: -1, r: -1 }, { q: 1, r: -2 }
                ];

                hexagons.forEach(hex => {
                    const pos = hexToPixel(hex.q, hex.r, s);
                    const points = createHexagonPoints(pos.x, pos.y, s);
                    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    polygon.setAttribute('points', points);
                    polygon.setAttribute('class', 'hex-tile flipped');
                    g.appendChild(polygon);
                });

                const trapezoids = [
                    { q: 2, r: 0, dir: 1 }, { q: 0, r: 2, dir: 2 },
                    { q: -2, r: 2, dir: 3 }, { q: -2, r: 0, dir: 4 },
                    { q: 0, r: -2, dir: 5 }, { q: 2, r: -2, dir: 0 }
                ];

                trapezoids.forEach(trap => {
                    const pos = hexToPixel(trap.q, trap.r, s);
                    const points = createTrapezoidPoints(pos.x, pos.y, s, trap.dir);
                    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    polygon.setAttribute('points', points);
                    polygon.setAttribute('class', 'hex-tile trapezoid flipped');
                    g.appendChild(polygon);
                });

                // Add empty center hex for visual reference (no fill)
                const centerPos = hexToPixel(0, 0, s);
                const centerPoints = createHexagonPoints(centerPos.x, centerPos.y, s);
                const centerPolygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                centerPolygon.setAttribute('points', centerPoints);
                centerPolygon.setAttribute('class', 'hex-tile empty-center');
                g.appendChild(centerPolygon);
            } else {
                // Normal side: all hexagons
                const hexagons = [
                    { q: 0, r: 0, class: 'center-hex' },
                    { q: 1, r: 0 }, { q: 0, r: 1 }, { q: -1, r: 1 },
                    { q: -1, r: 0 }, { q: 0, r: -1 }, { q: 1, r: -1 },
                    { q: 2, r: -1 }, { q: 1, r: 1 }, { q: -1, r: 2 },
                    { q: -2, r: 1 }, { q: -1, r: -1 }, { q: 1, r: -2 }
                ];

                hexagons.forEach(hex => {
                    const pos = hexToPixel(hex.q, hex.r, s);
                    const points = createHexagonPoints(pos.x, pos.y, s);
                    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    polygon.setAttribute('points', points);
                    polygon.setAttribute('class', `hex-tile ${hex.class || ''}`);
                    g.appendChild(polygon);
                });

                const trapezoids = [
                    { q: 2, r: 0, dir: 1 }, { q: 0, r: 2, dir: 2 },
                    { q: -2, r: 2, dir: 3 }, { q: -2, r: 0, dir: 4 },
                    { q: 0, r: -2, dir: 5 }, { q: 2, r: -2, dir: 0 }
                ];

                trapezoids.forEach(trap => {
                    const pos = hexToPixel(trap.q, trap.r, s);
                    const points = createTrapezoidPoints(pos.x, pos.y, s, trap.dir);
                    const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    polygon.setAttribute('points', points);
                    polygon.setAttribute('class', 'hex-tile trapezoid');
                    g.appendChild(polygon);
                });
            }

            return g;
        }

        function drawDeckTile() {
            deckTileSvg.innerHTML = '';
            const tile = createTileGroup(6, currentRotation, currentFlipped);
            tile.setAttribute('transform', 'translate(75, 75)');
            deckTileSvg.appendChild(tile);
        }

        function initializePlayerTiles(numPlayers) {
            const playerTileDeck = document.getElementById('player-tile-deck');
            playerTileDeck.innerHTML = '';
            playerTileElements = [];
            playerTilesAvailable = numPlayers;
            document.getElementById('player-tile-count').textContent = numPlayers;

            for (let i = 0; i < numPlayers; i++) {
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '150');
                svg.setAttribute('height', '150');
                svg.setAttribute('class', 'deck-tile player-tile-deck-item');
                svg.setAttribute('data-player-index', i);

                const tile = createTileGroup(6, 0, false); // Player tiles are not flipped
                tile.setAttribute('transform', 'translate(75, 75)');
                svg.appendChild(tile);

                playerTileDeck.appendChild(svg);
                playerTileElements.push(svg);

                // Add mousedown event for dragging
                svg.addEventListener('mousedown', (e) => {
                    if (playerTilesAvailable <= 0) return;
                    if (e.button === 0) {
                        startPlayerTileDrag(i, e);
                    }
                });

                // Add touch support for mobile
                svg.addEventListener('touchstart', (e) => {
                    if (playerTilesAvailable <= 0) return;
                    e.preventDefault();
                    startPlayerTileDrag(i, e);
                }, { passive: false });
            }
            if (isMobile) syncMobileTileDeck();

        }

        // Initialize a single player tile for multiplayer (only MY tile)
        function initializeMyPlayerTile(playerIndex, color) {
            const playerTileDeck = document.getElementById('player-tile-deck');
            playerTileDeck.innerHTML = '';
            playerTileElements = [];
            playerTilesAvailable = 1;
            document.getElementById('player-tile-count').textContent = '1';

            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '150');
            svg.setAttribute('height', '150');
            svg.setAttribute('class', 'deck-tile player-tile-deck-item');
            svg.setAttribute('data-player-index', playerIndex);

            const tile = createTileGroup(6, 0, false);
            tile.setAttribute('transform', 'translate(75, 75)');
            svg.appendChild(tile);

            // Add color indicator to show which player this is
            const colorCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            colorCircle.setAttribute('cx', '75');
            colorCircle.setAttribute('cy', '75');
            colorCircle.setAttribute('r', '12');
            colorCircle.setAttribute('fill', color);
            colorCircle.setAttribute('stroke', '#000');
            colorCircle.setAttribute('stroke-width', '2');
            svg.appendChild(colorCircle);

            playerTileDeck.appendChild(svg);
            playerTileElements.push(svg);

            // Add mousedown event for dragging
            svg.addEventListener('mousedown', (e) => {
                if (playerTilesAvailable <= 0) return;

                // In multiplayer placement phase, only allow drag if it's your turn
                if (isMultiplayer && isPlacementPhase && !canPlaceTile()) {
                    notYourTurn();
                    return;
                }

                if (e.button === 0) {
                    startPlayerTileDrag(playerIndex, e);
                }
            });

            // Add touch support for mobile
            svg.addEventListener('touchstart', (e) => {
                if (playerTilesAvailable <= 0) return;

                if (isMultiplayer && isPlacementPhase && !canPlaceTile()) {
                    notYourTurn();
                    return;
                }

                e.preventDefault();
                startPlayerTileDrag(playerIndex, e);
            }, { passive: false });
            if (isMobile) syncMobileTileDeck();

        }

        function startPlayerTileDrag(playerIndex, e) {
            isDraggingTile = true;
            draggedTileId = null;
            draggedTileRotation = 0;
            draggedTileFlipped = false;
            draggedTileShrineType = 'player'; // Mark as player tile
            draggedTileOriginalPos = null;

            const rect = boardSvg.getBoundingClientRect();
            const coords = getEventCoords(e);
            const screenX = coords.x - rect.left;
            const screenY = coords.y - rect.top;
            const world = screenToWorld(screenX, screenY);

            ghostTile = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            ghostTile.setAttribute('class', 'ghost-tile');
            ghostTile.setAttribute('transform', `translate(${world.x}, ${world.y})`);
            const tile = createTileGroup(TILE_SIZE, 0, false);
            ghostTile.appendChild(tile);
            viewport.appendChild(ghostTile);
        }

        function getAllHexagonPositions() {
            const positions = new Map();
            const trapezoidMap = new Map();

            placedTiles.forEach(tile => {
                const s = TILE_SIZE;

                // For flipped tiles, only include outer ring hexagons
                // For normal tiles and player tiles, include all hexagons
                // Player tiles look revealed but allow walking off them
                let hexagons;
                if (tile.flipped && !tile.isPlayerTile) {
                    hexagons = [
                        { q: 2, r: -1 }, { q: 1, r: 1 }, { q: -1, r: 2 },
                        { q: -2, r: 1 }, { q: -1, r: -1 }, { q: 1, r: -2 }
                    ];
                } else {
                    hexagons = [
                        { q: 0, r: 0 },
                        { q: 1, r: 0 }, { q: 0, r: 1 }, { q: -1, r: 1 },
                        { q: -1, r: 0 }, { q: 0, r: -1 }, { q: 1, r: -1 },
                        { q: 2, r: -1 }, { q: 1, r: 1 }, { q: -1, r: 2 },
                        { q: -2, r: 1 }, { q: -1, r: -1 }, { q: 1, r: -2 }
                    ];
                }

                hexagons.forEach(hex => {
                    const localPos = hexToPixel(hex.q, hex.r, s);
                    const globalX = tile.x + localPos.x;
                    const globalY = tile.y + localPos.y;
                    const roundedX = Math.round(globalX * 100) / 100;
                    const roundedY = Math.round(globalY * 100) / 100;
                    const key = `${roundedX},${roundedY}`;
                    if (!positions.has(key)) {
                        positions.set(key, { x: globalX, y: globalY, key, tiles: [tile] });
                    } else {
                        // Track which tiles contribute to this position
                        const existing = positions.get(key);
                        if (!existing.tiles.includes(tile)) {
                            existing.tiles.push(tile);
                        }
                    }
                });

                const trapezoids = [
                    { q: 2, r: 0 }, { q: 0, r: 2 }, { q: -2, r: 2 },
                    { q: -2, r: 0 }, { q: 0, r: -2 }, { q: 2, r: -2 }
                ];

                trapezoids.forEach(trap => {
                    const localPos = hexToPixel(trap.q, trap.r, s);
                    const globalX = tile.x + localPos.x;
                    const globalY = tile.y + localPos.y;
                    const roundedX = Math.round(globalX * 100) / 100;
                    const roundedY = Math.round(globalY * 100) / 100;
                    const key = `${roundedX},${roundedY}`;
                    if (!trapezoidMap.has(key)) {
                        trapezoidMap.set(key, { count: 1, x: globalX, y: globalY, key, tiles: [tile] });
                    } else {
                        const existing = trapezoidMap.get(key);
                        existing.count += 1;
                        if (!existing.tiles.includes(tile)) {
                            existing.tiles.push(tile);
                        }
                        if (existing.count >= 2 && !positions.has(key)) {
                            positions.set(key, { x: globalX, y: globalY, key, tiles: existing.tiles });
                        }
                    }
                });
            });

            return Array.from(positions.values());
        }

        function isPositionOnFlippedTile(x, y, hexPositions) {
            // Find the hex position that matches this x,y
            const matchingPos = hexPositions.find(pos => {
                const dist = Math.sqrt(Math.pow(pos.x - x, 2) + Math.pow(pos.y - y, 2));
                return dist < 5;
            });

            if (!matchingPos || !matchingPos.tiles) return false;

            // Check if ANY of the tiles contributing to this position are flipped (and not player tile)
            return matchingPos.tiles.some(tile => tile.flipped && !tile.isPlayerTile);
        }

        function findValidStonePosition(x, y) {
            const hexPositions = getAllHexagonPositions();
            let nearest = null;
            let minDist = Infinity;

            hexPositions.forEach(pos => {
                const dist = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
                if (dist < minDist) {
                    minDist = dist;
                    nearest = pos;
                }
            });

            if (nearest && minDist < TILE_SIZE * 2) {
                const occupied = placedStones.some(stone => {
                    const dist = Math.sqrt(Math.pow(stone.x - nearest.x, 2) + Math.pow(stone.y - nearest.y, 2));
                    return dist < 5;
                });

                const playerHere = playerPosition && Math.sqrt(Math.pow(playerPosition.x - nearest.x, 2) + Math.pow(playerPosition.y - nearest.y, 2)) < 5;

                const onFlippedTile = isPositionOnFlippedTile(nearest.x, nearest.y, hexPositions);

                // NEW: Check if position is adjacent to player
                const adjacentToPlayer = playerPosition && isAdjacentToPlayer(nearest.x, nearest.y);

                if (!occupied && !playerHere && !onFlippedTile && adjacentToPlayer) {
                    return { x: nearest.x, y: nearest.y, valid: true };
                }
            }

            return { x: x, y: y, valid: false };
        }

        function isAdjacentToPlayer(x, y) {
            if (!playerPosition) return false;
            
            // Get hex coordinates for both positions
            const playerHex = pixelToHex(playerPosition.x, playerPosition.y, TILE_SIZE);
            const targetHex = pixelToHex(x, y, TILE_SIZE);
            
            // Calculate axial distance
            const dq = Math.abs(playerHex.q - targetHex.q);
            const dr = Math.abs(playerHex.r - targetHex.r);
            const ds = Math.abs((-playerHex.q - playerHex.r) - (-targetHex.q - targetHex.r));
            
            // Adjacent means distance = 1 in hex coordinates
            const hexDistance = Math.max(dq, dr, ds);
            
            const isAdj = hexDistance === 1;
            console.log(`üîç isAdjacentToPlayer: player=(${playerHex.q},${playerHex.r}), target=(${targetHex.q},${targetHex.r}), distance=${hexDistance}, adjacent=${isAdj}`);
            
            return isAdj;
        }

        function findNearestHexPosition(x, y) {
            // Similar to findValidStonePosition, but doesn't care about stones/player
            // Used for player movement pathfinding
            const hexPositions = getAllHexagonPositions();
            let nearest = null;
            let minDist = Infinity;

            hexPositions.forEach(pos => {
                const dist = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
                if (dist < minDist) {
                    minDist = dist;
                    nearest = pos;
                }
            });

            if (nearest && minDist < TILE_SIZE * 2) {
                return { x: nearest.x, y: nearest.y, valid: true };
            }

            return { x: x, y: y, valid: false };
        }

        function findNearestSnapPoint(x, y, isPlayerTile = false) {
            const largeHexSize = TILE_SIZE * 4;
            const hexCoords = pixelToHex(x, y, largeHexSize);
            const snapPos = hexToPixel(hexCoords.q, hexCoords.r, largeHexSize);
            const distance = Math.sqrt(Math.pow(x - snapPos.x, 2) + Math.pow(y - snapPos.y, 2));

            if (distance < SNAP_THRESHOLD) {
                // Check if a tile already exists at this position
                const tileExists = placedTiles.some(tile => {
                    const dist = Math.sqrt(Math.pow(tile.x - snapPos.x, 2) + Math.pow(tile.y - snapPos.y, 2));
                    return dist < TILE_SIZE; // Tiles are considered overlapping if centers are very close
                });

                if (tileExists) {
                    return { x: x, y: y, snapped: false }; // Don't snap if position is occupied
                }

                // PLAYER TILE SPECIAL RULE: Must touch at least 2 unrevealed tiles
                if (isPlayerTile) {
                    const touchingUnrevealedCount = countTouchingUnrevealedTiles(snapPos.x, snapPos.y);
                    if (touchingUnrevealedCount < 2) {
                        console.log(`‚ùå Player tile at (${snapPos.x.toFixed(1)}, ${snapPos.y.toFixed(1)}) only touches ${touchingUnrevealedCount} unrevealed tile(s), need 2+`);
                        return { x: x, y: y, snapped: false }; // Don't allow placement
                    }
                    console.log(`‚úÖ Player tile at (${snapPos.x.toFixed(1)}, ${snapPos.y.toFixed(1)}) touches ${touchingUnrevealedCount} unrevealed tiles`);
                }

                return { x: snapPos.x, y: snapPos.y, snapped: true };
            }
            return { x: x, y: y, snapped: false };
        }

        function countTouchingUnrevealedTiles(tileX, tileY) {
            // Get the 6 adjacent tile positions in the large hex grid
            const largeHexSize = TILE_SIZE * 4;
            const tileHex = pixelToHex(tileX, tileY, largeHexSize);
            
            const adjacentOffsets = [
                { q: 1, r: 0 },   // East
                { q: 0, r: 1 },   // Southeast
                { q: -1, r: 1 },  // Southwest
                { q: -1, r: 0 },  // West
                { q: 0, r: -1 },  // Northwest
                { q: 1, r: -1 }   // Northeast
            ];

            let unrevealedCount = 0;

            adjacentOffsets.forEach(offset => {
                const adjQ = tileHex.q + offset.q;
                const adjR = tileHex.r + offset.r;
                const adjPos = hexToPixel(adjQ, adjR, largeHexSize);

                // Check if there's an unrevealed (flipped) tile at this position
                const adjacentTile = placedTiles.find(tile => {
                    const dist = Math.sqrt(Math.pow(tile.x - adjPos.x, 2) + Math.pow(tile.y - adjPos.y, 2));
                    return dist < TILE_SIZE;
                });

                if (adjacentTile && adjacentTile.flipped) {
                    unrevealedCount++;
                }
            });

            return unrevealedCount;
        }

        function tileHasStones(tileId) {
            const tile = placedTiles.find(t => t.id === tileId);
            if (!tile) return false;

            const s = TILE_SIZE;
            const hexagons = [
                { q: 0, r: 0 },
                { q: 1, r: 0 }, { q: 0, r: 1 }, { q: -1, r: 1 },
                { q: -1, r: 0 }, { q: 0, r: -1 }, { q: 1, r: -1 },
                { q: 2, r: -1 }, { q: 1, r: 1 }, { q: -1, r: 2 },
                { q: -2, r: 1 }, { q: -1, r: -1 }, { q: 1, r: -2 }
            ];

            return hexagons.some(hex => {
                const localPos = hexToPixel(hex.q, hex.r, s);
                const globalX = tile.x + localPos.x;
                const globalY = tile.y + localPos.y;

                return placedStones.some(stone => {
                    const dist = Math.sqrt(Math.pow(stone.x - globalX, 2) + Math.pow(stone.y - globalY, 2));
                    return dist < 5;
                });
            });
        }

        function updateTileClasses() {
            placedTiles.forEach(tile => {
                if (tileHasStones(tile.id)) {
                    tile.element.classList.add('has-stones');
                } else {
                    tile.element.classList.remove('has-stones');
                }
            });
        }

        function createShrineMarker(shrineType) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            g.setAttribute('class', 'shrine-marker');

            // Color mapping for shrine types
            const shrineColors = {
                'earth': '#69d83a',
                'water': '#5894f4',
                'fire': '#ed1b43',
                'wind': '#ffce00',
                'void': '#9458f4',
                'catacomb': '#8b4513'
            };

            // Symbol mapping for shrine types
            const shrineSymbols = {
                'earth': '‚ñ≤',
                'water': '‚óØ',
                'fire': '‚ô¶',
                'wind': '‚âã',
                'void': '‚ú∫',
                'catacomb': '‚ö∞'
            };

            // Create a circle background
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', '0');
            circle.setAttribute('cy', '0');
            circle.setAttribute('r', '8');
            circle.setAttribute('fill', shrineColors[shrineType]);
            circle.setAttribute('opacity', '0.6');
            circle.setAttribute('stroke', shrineColors[shrineType]);
            circle.setAttribute('stroke-width', '2');
            g.appendChild(circle);

            // Create the symbol text
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', '0');
            text.setAttribute('y', '0');
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('dominant-baseline', 'middle');
            text.setAttribute('fill', '#fff');
            text.setAttribute('font-size', '10');
            text.setAttribute('font-weight', 'bold');
            text.textContent = shrineSymbols[shrineType];
            g.appendChild(text);

            return g;
        }

        let nextTileId = 1; // Global counter for unique tile IDs

        function placeTile(x, y, rotation = 0, flipped = false, shrineType = null, isPlayerTile = false, skipMultiplayerLogic = false, forcedTileId = null) {
            console.log(`   placeTile called: x=${x.toFixed(1)}, y=${y.toFixed(1)}, rotation=${rotation}, flipped=${flipped}, shrineType=${shrineType}, isPlayerTile=${isPlayerTile}, skipMP=${skipMultiplayerLogic}`);
            const tileId = (forcedTileId !== null && forcedTileId !== undefined) ? forcedTileId : nextTileId++;
            if (forcedTileId !== null && forcedTileId !== undefined) {
                nextTileId = Math.max(nextTileId, forcedTileId + 1);
            }
            console.log(`   Assigned tileId: ${tileId}`);
            let tilePlayerIndex = null; // Will be set if this is a player tile
            const tileGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            tileGroup.setAttribute('class', isPlayerTile ? 'placed-tile player-tile' : 'placed-tile');
            tileGroup.setAttribute('data-tile-id', tileId);
            tileGroup.setAttribute('transform', `translate(${x}, ${y})`);

            const tile = createTileGroup(TILE_SIZE, rotation, flipped);
            tileGroup.appendChild(tile);

            // Draw from deck if shrine type not provided
            if (shrineType === null) {
                shrineType = drawNextTileFromDeck();
                if (shrineType === null) {
                    // No more tiles in deck
                    return null;
                }
            }

            // Check if this is the player tile
            if (shrineType === 'player') {
                isPlayerTile = true;

                const playerIndex = playerPositions.length;
                let assignedColor;

                // In multiplayer, use the pre-assigned playerColor
                // In local mode, assign colors in rank order
                if (isMultiplayer && playerColor) {
                    assignedColor = PLAYER_COLORS[playerColor];
                    console.log(`üé® Multiplayer - Using assigned color: ${playerColor} (${assignedColor})`);
                } else {
                    // Local game - assign next color in rank order
                    const colorRankOrder = ['purple', 'yellow', 'red', 'blue', 'green'];
                    if (playerIndex < 5) {
                        const colorName = colorRankOrder[playerIndex];
                        assignedColor = PLAYER_COLORS[colorName];
                        gameSessionColors.add(colorName);
                        playerColor = assignedColor;
                        console.log(`üé® Local game - Player ${playerIndex + 1} color assigned: ${colorName} (${assignedColor})`);
                    } else {
                        console.warn('‚ö†Ô∏è Maximum 5 players reached!');
                        assignedColor = '#fff'; // Fallback to white
                        playerColor = assignedColor;
                    }
                }

                // Add color tint overlay to player tile
                const tintOverlay = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                tintOverlay.setAttribute('cx', 0);
                tintOverlay.setAttribute('cy', 0);
                tintOverlay.setAttribute('r', TILE_SIZE * 2); // Cover the whole tile
                tintOverlay.setAttribute('fill', assignedColor);
                tintOverlay.setAttribute('opacity', '0.15'); // Light tint
                tintOverlay.setAttribute('pointer-events', 'none'); // Don't interfere with clicks
                tileGroup.appendChild(tintOverlay);

                // Store the player index for later use
                tilePlayerIndex = playerIndex;
                
                // Add a group for element symbols on the player tile
                const symbolsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                symbolsGroup.setAttribute('class', 'player-tile-element-symbols');
                tileGroup.appendChild(symbolsGroup);
            }

            // Only add shrine marker if NOT flipped and NOT player tile (revealed tiles show shrine)
            if (!flipped && shrineType !== 'player') {
                const shrineMarker = createShrineMarker(shrineType);
                tileGroup.appendChild(shrineMarker);
            }

            tileGroup.addEventListener('mousedown', (e) => {
                console.log(`üñ±Ô∏è Tile clicked: tileId=${tileId}, position=(${x.toFixed(1)}, ${y.toFixed(1)}), shrine=${shrineType}, flipped=${flipped}, isPlayerTile=${isPlayerTile}`);

                // Player tiles cannot be dragged once placed
                if (isPlayerTile) {
                    console.log(`   ‚úó Cannot drag: player tiles are locked in place`);
                    return;
                }

                if (e.button === 0 && !tileHasStones(tileId) && !isPanning && !isDraggingStone) {
                    console.log(`   ‚úì Starting drag for tile ${tileId} at (${x.toFixed(1)}, ${y.toFixed(1)})`);
                    e.stopPropagation();
                    e.preventDefault();
                    startTileDrag(tileId, e);
                } else {
                    console.log(`   ‚úó Cannot drag: hasStones=${tileHasStones(tileId)}, isPanning=${isPanning}, isDraggingStone=${isDraggingStone}`);
                }
            });

            // Touch support: start tile drag on tap/drag
            tileGroup.addEventListener('touchstart', (e) => {
                // Player tiles cannot be dragged once placed
                if (isPlayerTile) return;
                if (tileHasStones(tileId) || isPanning || isDraggingStone) return;

                if (e.touches && e.touches.length === 1) {
                    e.stopPropagation();
                    e.preventDefault();
                    const t = e.touches[0];
                    startTileDrag(tileId, {
                        clientX: t.clientX,
                        clientY: t.clientY,
                        button: 0,
                        preventDefault: () => {},
                        stopPropagation: () => {}
                    });
                }
            }, { passive: false });


            // Add hover tooltip for player tiles in multiplayer
            if (isPlayerTile && isMultiplayer) {
                let tooltip = null;

                tileGroup.addEventListener('mouseenter', (e) => {
                    tooltip = showPlayerTooltip(tilePlayerIndex, e.clientX, e.clientY);
                });

                tileGroup.addEventListener('mousemove', (e) => {
                    if (tooltip) {
                        tooltip.style.left = (e.clientX + 15) + 'px';
                        tooltip.style.top = (e.clientY + 15) + 'px';
                    }
                });

                tileGroup.addEventListener('mouseleave', () => {
                    if (tooltip && tooltip.parentNode) {
                        tooltip.parentNode.removeChild(tooltip);
                        tooltip = null;
                    }
                });
            }

            viewport.insertBefore(tileGroup, snapIndicator);

            placedTiles.push({
                id: tileId,
                x: x,
                y: y,
                rotation: rotation,
                flipped: flipped,
                element: tileGroup,
                shrineType: shrineType,
                isPlayerTile: isPlayerTile,
                playerIndex: isPlayerTile ? tilePlayerIndex : null // Track which player owns this tile
            });

            updateTileClasses();

            // Place player marker on player tile
            if (isPlayerTile) {
                // Create new player pawn at this tile's position
                placePlayer(x, y, playerColor);

                // In multiplayer, broadcast tile placement and track placement phase
                // Skip this logic if we're just placing visually from a broadcast
                if (isMultiplayer && !skipMultiplayerLogic) {
                    console.log(`üéÆ Player ${tilePlayerIndex} placed tile. Before: activePlayerIndex=${activePlayerIndex}, placed=${Array.from(playerTilesPlaced)}`);
                    playerTilesPlaced.add(tilePlayerIndex);

                    // Broadcast that this player placed their tile
                    broadcastGameAction('player-tile-placed', {
                        playerIndex: tilePlayerIndex
                    });

                    // Check if all players have placed tiles
                    if (playerTilesPlaced.size === totalPlayers) {
                        isPlacementPhase = false;
                        activePlayerIndex = 0; // Reset to first player for normal gameplay
                        console.log('‚úÖ All players have placed their tiles. Game begins!');

                        // Broadcast placement phase end and turn reset
                        const startedAt = Date.now();
                        turnStartedAtMs = startedAt;
                        broadcastGameAction('placement-complete', {
                            playerIndex: 0,
                            turnStartedAt: startedAt
                        });

                        if (isMyTurn()) {
                            updateStatus(`‚úÖ All tiles placed! It's your turn!`);
                        } else {
                            const nextColorName = getPlayerColorName(activePlayerIndex);
                            updateStatus(`‚úÖ All tiles placed! Waiting for ${nextColorName}'s turn...`);
                        }
                    } else {
                        // Advance to next player in turn order
                        const oldIndex = activePlayerIndex;
                        activePlayerIndex = (activePlayerIndex + 1) % totalPlayers;
                        console.log(`üîÑ Advancing turn: ${oldIndex} -> ${activePlayerIndex} (total: ${totalPlayers})`);

                        // Broadcast turn change during placement phase
                        const startedAt = Date.now();
                    turnStartedAtMs = startedAt;
                    broadcastGameAction('turn-change', {
                        playerIndex: activePlayerIndex,
                        turnStartedAt: startedAt
                    });
                        console.log(`üì° Broadcasted turn-change to player ${activePlayerIndex}`);

                        if (canPlaceTile()) {
                            updateStatus(`Your turn! Place your player tile (${playerTilesPlaced.size}/${totalPlayers} placed)`);
                        setInventoryOpen(true);
                            console.log(`‚úÖ My turn to place (myPlayerIndex=${myPlayerIndex})`);
                        } else {
                            const nextColorName = getPlayerColorName(activePlayerIndex);
                            updateStatus(`Waiting for ${nextColorName} to place their tile... (${playerTilesPlaced.size}/${totalPlayers})`);
                            console.log(`‚è≥ Waiting for player ${activePlayerIndex} (myPlayerIndex=${myPlayerIndex})`);
                        }
                    }
                } else {
                    updateStatus(`Player ${tilePlayerIndex + 1} tile placed!`);
                }
            }

            return tileId;
        }

        function revealTile(tileId) {
            const tile = placedTiles.find(t => t.id === tileId);
            if (!tile || !tile.flipped) {
                console.log(`‚ö†Ô∏è revealTile called for tile ${tileId}, but tile is ${tile ? 'already revealed' : 'not found'}`);
                return; // Already revealed or doesn't exist
            }

            console.log(`üì° Broadcasting tile flip: tileId=${tileId}, shrineType=${tile.shrineType}`);
            // Broadcast tile flip to other players
            broadcastGameAction('tile-flip', {
                tileId: tileId,
                shrineType: tile.shrineType
            });

            // Remove the old tile element
            tile.element.remove();

            // Create new revealed tile group
            const tileGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            tileGroup.setAttribute('class', 'placed-tile');
            tileGroup.setAttribute('data-tile-id', tileId);
            tileGroup.setAttribute('transform', `translate(${tile.x}, ${tile.y})`);

            const tileGraphic = createTileGroup(TILE_SIZE, tile.rotation, false);
            tileGroup.appendChild(tileGraphic);

            // Add shrine marker
            const shrineMarker = createShrineMarker(tile.shrineType);
            tileGroup.appendChild(shrineMarker);

            tileGroup.addEventListener('mousedown', (e) => {
                if (e.button === 0 && !tileHasStones(tileId) && !isPanning && !isDraggingStone) {
                    e.stopPropagation();
                    e.preventDefault();
                    startTileDrag(tileId, e);
                }
            });

            viewport.insertBefore(tileGroup, snapIndicator);

            // Update tile data
            tile.flipped = false;
            tile.element = tileGroup;

            // Check for scroll discovery
            const scrollInfo = spellSystem.onTileRevealed(tile.shrineType);
            if (scrollInfo) {
                updateStatus(`Revealed ${tile.shrineType} shrine! Found ${scrollInfo.name}!`);
            } else {
                updateStatus(`Revealed ${tile.shrineType} shrine!`);
            }
        }

        // Visual-only tile flip (called when receiving broadcast from other players)
        function flipTileVisually(tileElement, shrineType) {
            const tileId = parseInt(tileElement.getAttribute('data-tile-id'));
            const tile = placedTiles.find(t => t.id === tileId);
            if (!tile || !tile.flipped) return;

            // Same visual logic as revealTile but without broadcasting
            tile.element.remove();

            const tileGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            tileGroup.setAttribute('class', 'placed-tile');
            tileGroup.setAttribute('data-tile-id', tileId);
            tileGroup.setAttribute('transform', `translate(${tile.x}, ${tile.y})`);

            const tileGraphic = createTileGroup(TILE_SIZE, tile.rotation, false);
            tileGroup.appendChild(tileGraphic);

            const shrineMarker = createShrineMarker(shrineType);
            tileGroup.appendChild(shrineMarker);

            tileGroup.addEventListener('mousedown', (e) => {
                if (e.button === 0 && !tileHasStones(tileId) && !isPanning && !isDraggingStone) {
                    e.stopPropagation();
                    e.preventDefault();
                    startTileDrag(tileId, e);
                }
            });

            viewport.insertBefore(tileGroup, snapIndicator);

            tile.flipped = false;
            tile.element = tileGroup;
        }

        function startTileDrag(tileId, e) {
            if (tileHasStones(tileId)) return;
            isDraggingTile = true;
            draggedTileId = tileId;
            draggedTileShrineType = null;
            draggedTileOriginalPos = null;
            const tile = placedTiles.find(t => t.id === tileId);
            if (tile) {
                draggedTileRotation = tile.rotation;
                draggedTileFlipped = tile.flipped || false;
                draggedTileShrineType = tile.shrineType; // Preserve shrine type
                draggedTileOriginalPos = { x: tile.x, y: tile.y }; // Store original position
                tile.element.remove();
                placedTiles = placedTiles.filter(t => t.id !== tileId);
            }

            const rect = boardSvg.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            const world = screenToWorld(screenX, screenY);

            ghostTile = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            ghostTile.setAttribute('class', 'ghost-tile');
            ghostTile.setAttribute('transform', `translate(${world.x}, ${world.y})`);
            const tileContent = createTileGroup(TILE_SIZE, draggedTileRotation, draggedTileFlipped);
            ghostTile.appendChild(tileContent);
            viewport.appendChild(ghostTile);
        }

        let isDraggingPlayer = false;
        let ghostPlayer = null;
        let playerPath = [];
        let pathLine = null;
        let pathCostLabels = [];

        
        // Finalize a pawn move based on the currently drawn playerPath (used by touch + mouse).
        function movePlayerAlongPath() {
            if (!isDraggingPlayer || !ghostPlayer || playerPath.length < 2) return;

            const activePlayer = playerPositions[activePlayerIndex];
            if (!activePlayer) return;

            const finalPos = playerPath[playerPath.length - 1];

            // Basic legality check for destination (revealed/unrevealed rules are enforced in canPlayerMoveToHex)
            const canMoveCheck = canPlayerMoveToHex(finalPos.x, finalPos.y, true);
            if (!canMoveCheck.canMove) {
                console.log(`‚ùå Invalid move end: ${canMoveCheck.reason || 'cannot move there'}`);
                // cleanup happens below
            } else {
                // Total cost for the selected path
                const totalCost = playerPath.reduce((sum, step, i) => {
                    if (i === 0) return 0;
                    return sum + (step.cost || 1);
                }, 0);

                // Make sure player has enough AP
                const availableAP = getCurrentAP ? getCurrentAP() : currentAP;
                if (totalCost > availableAP) {
                    console.log(`‚ùå Not enough AP: need ${totalCost}, have ${availableAP}`);
                } else {
                    // Spend AP and apply the move
                    if (typeof spendAP === 'function') spendAP(totalCost);

                    // Move pawn visually + state
                    activePlayer.x = finalPos.x;
                    activePlayer.y = finalPos.y;
                    activePlayer.element.setAttribute('transform', `translate(${finalPos.x}, ${finalPos.y})`);
                    if (ghostPlayer) ghostPlayer.setAttribute('transform', `translate(${finalPos.x}, ${finalPos.y})`);

                    console.log(`‚úÖ Movement successful: ${playerPath.length - 1} hexes, cost ${totalCost} AP`);

                    // Record activity + broadcast movement (multiplayer)
                    try {
                        recordActivity && recordActivity('move', { x: finalPos.x, y: finalPos.y, apSpent: totalCost });
                    } catch (e) {}

                    if (typeof broadcastPlayerMovement === 'function' && !isSpectator) {
                        try {
                            broadcastPlayerMovement(activePlayerIndex, finalPos.x, finalPos.y, totalCost);
                        } catch (e) {}
                    }

                    // Tile reveal / shrine resolution (reuse existing landing handler if present)
                    try {
                        if (typeof handlePlayerLanding === 'function') {
                            handlePlayerLanding(finalPos.x, finalPos.y);
                        } else if (typeof checkTileRevealsAtPosition === 'function') {
                            checkTileRevealsAtPosition(finalPos.x, finalPos.y);
                        }
                    } catch (e) {
                        console.warn('Landing/reveal handler error:', e);
                    }
                }
            }

            // Cleanup (match mouseup behavior)
            isDraggingPlayer = false;
            clearPlayerPath();
            if (ghostPlayer) {
                ghostPlayer.remove();
                ghostPlayer = null;
            }
        }

function clearPlayerPath() {
            // Remove polyline
            if (pathLine) {
                pathLine.remove();
                pathLine = null;
            }
            // Remove step/cost labels
            if (pathCostLabels && pathCostLabels.length) {
                pathCostLabels.forEach(label => {
                    try { label.remove(); } catch (e) {}
                });
            }
            pathCostLabels = [];
            playerPath = [];
            snapIndicator.classList.remove('active');
        }


        function placePlayer(x, y, color = null) {
            if (color) {
                // Creating a NEW player pawn with this color
                console.log(`üé® Creating new player ${playerPositions.length + 1} at (${x.toFixed(1)}, ${y.toFixed(1)}) with color ${color}`);

                const playerGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                playerGroup.setAttribute('class', 'player');
                playerGroup.setAttribute('transform', `translate(${x}, ${y})`);
                playerGroup.style.pointerEvents = 'all';
                playerGroup.style.touchAction = 'none';

                // Invisible larger hit area for easier touch targeting
                const hitArea = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                hitArea.setAttribute('cx', 0);
                hitArea.setAttribute('cy', 0);
                hitArea.setAttribute('r', TILE_SIZE * 0.8); // Much larger touch target
                hitArea.setAttribute('fill', 'transparent');
                hitArea.setAttribute('stroke', 'none');
                hitArea.style.pointerEvents = 'all';
                playerGroup.appendChild(hitArea);

                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', 0);
                circle.setAttribute('cy', 0);
                circle.setAttribute('r', TILE_SIZE * 0.4);
                circle.setAttribute('class', 'player-marker');
                circle.setAttribute('fill', color);
                circle.setAttribute('stroke', '#000');
                circle.setAttribute('stroke-width', '2');

                playerGroup.appendChild(circle);

                // Store the player index for this group
                const playerIndex = playerPositions.length;

                // Add drag handler
                playerGroup.addEventListener('mousedown', (e) => {
                    // Only draggable if this is the active player (check dynamically)
                    const thisPlayerIndex = playerPositions.findIndex(p => p.element === playerGroup);
                    if (thisPlayerIndex === activePlayerIndex) {
                        e.stopPropagation();
                        e.preventDefault();
                        startPlayerDrag(e);
                    }
                });

            // Touch support: start player drag on tap/drag
	            playerGroup.addEventListener('touchstart', (e) => {
	                console.log('üéØ Player pawn touchstart detected!', {touches: e.touches?.length, target: e.target});
	                if (!(e.touches && e.touches.length === 1)) return;
	                // Mirror mousedown behavior: only the active player pawn can be dragged
	                const thisPlayerIndex = playerPositions.findIndex(p => p.element === playerGroup);
	                console.log(`   thisPlayerIndex=${thisPlayerIndex}, activePlayerIndex=${activePlayerIndex}`);
	                if (thisPlayerIndex === activePlayerIndex) {
                    e.stopPropagation();
                    e.preventDefault();
                    const t = e.touches[0];
                    console.log('   ‚úÖ Starting player drag from touch');
                    startPlayerDrag({
                        clientX: t.clientX,
                        clientY: t.clientY,
                        button: 0,
                        preventDefault: () => {},
                        stopPropagation: () => {}
                    });
                } else {
                    console.log('   ‚ùå Not active player, ignoring touch');
                }
            }, { passive: false });

                playerGroup.addEventListener('mouseenter', (e) => {
                    e.stopPropagation();
                });

                playerGroup.addEventListener('mouseleave', (e) => {
                    e.stopPropagation();
                });

                viewport.appendChild(playerGroup);
                playerPositions.push({ x, y, element: playerGroup, color, index: playerIndex });
                
            } else {
                // Moving the ACTIVE player
                const activePlayer = playerPositions[activePlayerIndex];
                if (!activePlayer) {
                    console.error('No active player to move!');
                    return;
                }
                
                activePlayer.element.remove();

                const playerGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                playerGroup.setAttribute('class', 'player');
                playerGroup.setAttribute('transform', `translate(${x}, ${y})`);
                playerGroup.style.pointerEvents = 'all';
                playerGroup.style.touchAction = 'none';

                // Invisible larger hit area for easier touch targeting
                const hitArea = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                hitArea.setAttribute('cx', 0);
                hitArea.setAttribute('cy', 0);
                hitArea.setAttribute('r', TILE_SIZE * 0.8);
                hitArea.setAttribute('fill', 'transparent');
                hitArea.setAttribute('stroke', 'none');
                hitArea.style.pointerEvents = 'all';
                playerGroup.appendChild(hitArea);

                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', 0);
                circle.setAttribute('cy', 0);
                circle.setAttribute('r', TILE_SIZE * 0.4);
                circle.setAttribute('class', 'player-marker');
                circle.setAttribute('fill', activePlayer.color);
                circle.setAttribute('stroke', '#000');
                circle.setAttribute('stroke-width', '2');

                playerGroup.appendChild(circle);

                // Store the player index for event handlers
                const thisPlayerIdx = activePlayerIndex;

                playerGroup.addEventListener('mousedown', (e) => {
                    // Only draggable if this is the active player
                    const currentIdx = playerPositions.findIndex(p => p.element === playerGroup);
                    if (currentIdx === activePlayerIndex) {
                        e.stopPropagation();
                        e.preventDefault();
                        startPlayerDrag(e);
                    }
                });

	            // Touch support: start player drag on tap/drag
	            playerGroup.addEventListener('touchstart', (e) => {
	                console.log('üéØ Player pawn touchstart (path2) detected!', {touches: e.touches?.length});
	                if (!(e.touches && e.touches.length === 1)) return;
	                // Mirror mousedown behavior: only active player can be dragged
	                const currentIdx = playerPositions.findIndex(p => p.element === playerGroup);
	                console.log(`   currentIdx=${currentIdx}, activePlayerIndex=${activePlayerIndex}`);
	                if (currentIdx === activePlayerIndex) {
                    e.stopPropagation();
                    e.preventDefault();
                    const t = e.touches[0];
                    console.log('   ‚úÖ Starting player drag from touch (path2)');
                    startPlayerDrag({
                        clientX: t.clientX,
                        clientY: t.clientY,
                        button: 0,
                        preventDefault: () => {},
                        stopPropagation: () => {}
                    });
                } else {
                    console.log('   ‚ùå Not active player, ignoring touch (path2)');
                }
            }, { passive: false });

                playerGroup.addEventListener('mouseenter', (e) => {
                    e.stopPropagation();
                });

                playerGroup.addEventListener('mouseleave', (e) => {
                    e.stopPropagation();
                });

                viewport.appendChild(playerGroup);

                activePlayer.x = x;
                activePlayer.y = y;
                activePlayer.element = playerGroup;
            }

            // Update catacomb teleport indicators
            updateCatacombIndicators();
        }

        // Visual-only player tile placement (called when receiving broadcast from other players)
        function placePlayerTileVisually(x, y, playerIndex, colorName) {
            console.log(`üîÑ Placing other player's tile: player ${playerIndex}, color ${colorName}, at (${x.toFixed(1)}, ${y.toFixed(1)})`);

            // Temporarily set playerColor to the other player's color
            const originalColor = playerColor;
            playerColor = colorName;

            // Place the player tile - skip multiplayer logic since this is visual-only
            placeTile(x, y, 0, false, 'player', true, true);

            // Restore our color
            playerColor = originalColor;

            console.log(`‚úÖ Other player's tile placed successfully (visual only)`);
        }

        // Visual-only player movement (called when receiving broadcast from other players)
        function movePlayerVisually(playerIndex, x, y, apSpent) {
            const player = playerPositions[playerIndex];
            if (!player) {
                console.error(`Cannot move player ${playerIndex} - not found`);
                return;
            }

            // Remove old player element
            player.element.remove();

            // Create new player element at new position
            const playerGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            playerGroup.setAttribute('class', 'player');
            playerGroup.setAttribute('transform', `translate(${x}, ${y})`);
            playerGroup.style.pointerEvents = 'all';
            playerGroup.style.touchAction = 'none';

            // Invisible larger hit area for easier touch targeting
            const hitArea = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            hitArea.setAttribute('cx', 0);
            hitArea.setAttribute('cy', 0);
            hitArea.setAttribute('r', TILE_SIZE * 0.8);
            hitArea.setAttribute('fill', 'transparent');
            hitArea.setAttribute('stroke', 'none');
            hitArea.style.pointerEvents = 'all';
            playerGroup.appendChild(hitArea);

            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', 0);
            circle.setAttribute('cy', 0);
            circle.setAttribute('r', TILE_SIZE * 0.4);
            circle.setAttribute('class', 'player-marker');
            circle.setAttribute('fill', player.color);
            circle.setAttribute('stroke', '#000');
            circle.setAttribute('stroke-width', '2');

            playerGroup.appendChild(circle);

            playerGroup.addEventListener('mousedown', (e) => {
	                if (activePlayerIndex === playerIndex) {
                    e.stopPropagation();
                    e.preventDefault();
                    startPlayerDrag(e);
                }
            });

	            // Touch support: start player drag on tap/drag
	            playerGroup.addEventListener('touchstart', (e) => {
	                console.log('üéØ Player pawn touchstart (path3) detected!', {touches: e.touches?.length, playerIndex});
	                if (!(e.touches && e.touches.length === 1)) return;
	                // Mirror mousedown behavior: only active player can be dragged
	                console.log(`   playerIndex=${playerIndex}, activePlayerIndex=${activePlayerIndex}`);
	                if (activePlayerIndex === playerIndex) {
                    e.stopPropagation();
                    e.preventDefault();
                    const t = e.touches[0];
                    console.log('   ‚úÖ Starting player drag from touch (path3)');
                    startPlayerDrag({
                        clientX: t.clientX,
                        clientY: t.clientY,
                        button: 0,
                        preventDefault: () => {},
                        stopPropagation: () => {}
                    });
                } else {
                    console.log('   ‚ùå Not active player, ignoring touch (path3)');
                }
            }, { passive: false });

            viewport.appendChild(playerGroup);

            // Update player position
            player.x = x;
            player.y = y;
            player.element = playerGroup;

            console.log(`üîÑ Moved player ${playerIndex} to (${x.toFixed(1)}, ${y.toFixed(1)}), spent ${apSpent} AP`);
        }

        // Visual-only stone break (called when receiving broadcast from other players)
        function breakStoneVisually(stoneId) {
            const stone = placedStones.find(s => s.id === stoneId);
            if (!stone) {
                console.log(`‚ö†Ô∏è Cannot break stone ${stoneId} - not found`);
                return;
            }

            console.log(`üí• Breaking stone visually: id=${stoneId}, type=${stone.type}`);

            // Remove stone from board
            const stoneElement = stone.element;
            if (stoneElement && stoneElement.parentNode) {
                stoneElement.remove();
            }

            // Remove from placedStones array
            const index = placedStones.findIndex(s => s.id === stoneId);
            if (index !== -1) {
                placedStones.splice(index, 1);
            }

            // Return stone to source pool
            returnStoneToPool(stone.type);

            // Update interactions since a stone was removed
            updateTileClasses();
            recheckAllStoneInteractions();
            updateAllWaterStoneVisuals();
            updateAllVoidNullificationVisuals();

            console.log(`‚úÖ Stone ${stoneId} broken visually`);
        }

        // Record player activity (kept for analytics/debug; NOT used for kicking)
        function recordActivity() {
            if (!myPlayerId) return;
            myLastActivity = Date.now();
            playerLastActivity[myPlayerId] = myLastActivity;
            // Turn timeout is based on turn start time, not activity.
            console.log('üì° Activity recorded locally');
        }


        // Update turn timer display (shared by everyone; enforced by host)
        function updateTimerDisplay() {
            const timerElement = document.getElementById('inactivity-timer');
            if (!timerElement || !gameInactivityTimeout || gameInactivityTimeout === 0) {
                if (timerElement) timerElement.style.display = 'none';
                return;
            }

            // Only show timer when it's my turn (during placement phase, this means "canPlaceTile()")
            const isMyActiveTurn = isPlacementPhase ? canPlaceTile() : isMyTurn();
            if (!isMyActiveTurn) {
                timerElement.style.display = 'none';
                return;
            }

            const now = Date.now();
            const elapsed = now - (turnStartedAtMs || now);
            const timeRemaining = gameInactivityTimeout - elapsed;

            if (timeRemaining <= 0) {
                timerElement.style.display = 'none';
                return;
            }

            // Show timer
            timerElement.style.display = 'inline-block';

            // Calculate percentage remaining
            const percentRemaining = (timeRemaining / gameInactivityTimeout) * 100;

            // Format time
            const secondsRemaining = Math.ceil(timeRemaining / 1000);
            const minutes = Math.floor(secondsRemaining / 60);
            const seconds = secondsRemaining % 60;
            const timeText = minutes > 0 ? `${minutes}:${seconds.toString().padStart(2, '0')}` : `${seconds}s`;

            // Color-code based on time remaining
            let color, bgColor, label;
            if (percentRemaining > 75) {
                color = '#fff';
                bgColor = '#4CAF50';
                label = '‚è±Ô∏è';
            } else if (percentRemaining > 50) {
                color = '#000';
                bgColor = '#FFEB3B';
                label = '‚è±Ô∏è';
            } else if (percentRemaining > 25) {
                color = '#fff';
                bgColor = '#FF9800';
                label = '‚ö†Ô∏è';
            } else {
                color = '#fff';
                bgColor = '#f44336';
                label = 'üî•';
            }

            timerElement.style.backgroundColor = bgColor;
            timerElement.style.color = color;
            timerElement.textContent = `${label} ${timeText}`;
        }

        // Start timer display updates
        function startTimerDisplay() {
            // Clear any existing interval
            if (timerDisplayInterval) {
                clearInterval(timerDisplayInterval);
            }

            // Update display every second
            timerDisplayInterval = setInterval(updateTimerDisplay, 1000);
            updateTimerDisplay(); // Initial update
        }

        // Stop timer display
        function stopTimerDisplay() {
            if (timerDisplayInterval) {
                clearInterval(timerDisplayInterval);
                timerDisplayInterval = null;
            }
            const timerElement = document.getElementById('inactivity-timer');
            if (timerElement) {
                timerElement.style.display = 'none';
            }
        }

        // Turn timeout enforcement (host only)
        async function checkTurnTimeout() {
            if (!isMultiplayer) return;
            if (!isHost) return;
            if (!gameInactivityTimeout || gameInactivityTimeout === 0) return; // disabled

            // Only enforce during active game
            const { data: room, error: roomErr } = await supabase
                .from('game_room')
                .select('status')
                .eq('id', 1)
                .single();

            if (roomErr) {
                console.warn('‚ö†Ô∏è Turn timeout: failed to read room status', roomErr);
                return;
            }

            if (!room || room.status !== 'playing') return;

            const now = Date.now();
            const elapsed = now - (turnStartedAtMs || now);
            if (elapsed < gameInactivityTimeout) return;

            // Time is up ‚Äî either kick active player or auto-advance
            console.log('‚è∞ Turn timer expired. kickOnTurnTimeout:', kickOnTurnTimeout, 'activePlayerIndex:', activePlayerIndex);

            if (kickOnTurnTimeout) {
                // Kick active player
                const { data: allPlayers } = await supabase
                    .from('players')
                    .select('id, username, player_index');

                const activePlayer = allPlayers?.find(p => p.player_index === activePlayerIndex);

                if (activePlayer) {
                    const { error: kickErr } = await supabase
                        .from('players')
                        .delete()
                        .eq('id', activePlayer.id);

                    if (kickErr) {
                        console.error('‚ùå Failed to kick player (turn timeout):', kickErr);
                        return;
                    }

                    updateStatus(`‚è∞ ${activePlayer.username} was kicked (turn timer expired)`);
                } else {
                    console.warn('‚ö†Ô∏è Turn timeout expired but active player not found in DB');
                }
            } else {
                updateStatus('‚è∞ Turn timer expired ‚Äî auto-passing turn.');
            }

            // Advance to next available player and restart the timer
            await hostAdvanceToNextPlayerAndRestartTimer();
        }

        async function hostAdvanceToNextPlayerAndRestartTimer() {
            // Fetch remaining players and choose the next index based on player_index ordering
            const { data: remainingPlayers, error } = await supabase
                .from('players')
                .select('player_index')
                .order('player_index', { ascending: true });

            if (error) {
                console.error('‚ùå Failed to read players to advance turn:', error);
                return;
            }

            const indices = (remainingPlayers || [])
                .map(p => p.player_index)
                .filter(i => i !== null && i !== undefined)
                .sort((a, b) => a - b);

            if (indices.length === 0) return;

            // Find next index after current; wrap around
            let nextIndex = indices.find(i => i > activePlayerIndex);
            if (nextIndex === undefined) nextIndex = indices[0];

            activePlayerIndex = nextIndex;

            // Restart timer anchored to host time
            const started = Date.now();
            turnStartedAtMs = started;

            // Broadcast turn change with shared turn start timestamp
            broadcastGameAction('turn-change', {
                playerIndex: activePlayerIndex,
                turnStartedAt: started
            });

            // Update local display as host
            if (isPlacementPhase) {
                // During placement phase, turn display is handled in the turn-change receiver
            } else {
                updateTurnDisplay();
            }
        }

        // Start turn timer monitoring (host enforcement + local display)
        function startTurnTimerMonitoring() {
            // Stop any existing
            stopTurnTimerMonitoring();

            // Ensure we have a baseline turn start
            if (!turnStartedAtMs) turnStartedAtMs = Date.now();

            // Host enforces every second
            if (isHost) {
                turnTimeoutInterval = setInterval(() => {
                    // avoid unhandled promise rejections
                    checkTurnTimeout().catch(err => console.error('Turn timeout check failed:', err));
                }, 1000);
            }

            // Everyone updates display every second
            startTimerDisplay();
        }

        // Stop turn timer monitoring
        function stopTurnTimerMonitoring() {
            if (turnTimeoutInterval) {
                clearInterval(turnTimeoutInterval);
                turnTimeoutInterval = null;
            }
            stopTimerDisplay();
        }

        // Sync current player state (AP and resources) in multiplayer (AP and resources) in multiplayer
        function syncPlayerState() {
            if (!isMultiplayer) return;

            // Record activity
            recordActivity();

            // Update local tracking
            if (!playerAPs[activePlayerIndex]) {
                playerAPs[activePlayerIndex] = { currentAP: 5, voidAP: 0 };
            }
            playerAPs[activePlayerIndex].currentAP = currentAP;
            playerAPs[activePlayerIndex].voidAP = voidAP;

            // Broadcast state
            broadcastGameAction('player-state-update', {
                playerIndex: activePlayerIndex,
                currentAP: currentAP,
                voidAP: voidAP,
                resources: playerPool // Current player's resources
            });
        }

        // Show tooltip with player's AP and resources
        function showPlayerTooltip(playerIndex, mouseX, mouseY) {
            const tooltip = document.createElement('div');
            tooltip.className = 'player-tooltip';
            tooltip.style.left = (mouseX + 15) + 'px';
            tooltip.style.top = (mouseY + 15) + 'px';

            // Get player name
            const playerName = getPlayerColorName(playerIndex);

            // Get player's resources
            const playerPool = playerPools[playerIndex] || { earth: 0, water: 0, fire: 0, wind: 0, void: 0 };
            const playerAP = playerAPs[playerIndex] || { currentAP: 5, voidAP: 0 };

            // Build tooltip content
            let html = `<div class="tooltip-header">${playerName}</div>`;

            // AP info
            html += `<div class="tooltip-row">
                <span class="tooltip-label">AP:</span>
                <span>${playerAP.currentAP}/5</span>
            </div>`;

            if (playerAP.voidAP > 0) {
                html += `<div class="tooltip-row">
                    <span class="tooltip-label" style="color: #9458f4;">Void AP:</span>
                    <span style="color: #9458f4;">${playerAP.voidAP}</span>
                </div>`;
            }

            // Resources
            html += `<div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #555;">`;
            html += `<div style="margin-bottom: 5px; color: #999;">Stone Resources:</div>`;

            const elementSymbols = { earth: '‚ñ≤', water: '‚óØ', fire: '‚ô¶', wind: '‚âã', void: '‚ú∫' };
            const elementColors = { earth: '#69d83a', water: '#5894f4', fire: '#ed1b43', wind: '#ffce00', void: '#9458f4' };

            ['earth', 'water', 'fire', 'wind', 'void'].forEach(element => {
                if (playerPool[element] > 0) {
                    html += `<div class="tooltip-row">
                        <span style="color: ${elementColors[element]};">${elementSymbols[element]} ${element}:</span>
                        <span>${playerPool[element]}/5</span>
                    </div>`;
                }
            });

            html += `</div>`;

            // Scrolls
            const playerScrollData = spellSystem.playerScrolls[playerIndex];
            if (playerScrollData && playerScrollData.collected.size > 0) {
                html += `<div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #555;">`;
                html += `<div style="margin-bottom: 5px; color: #999;">Scrolls Collected:</div>`;

                // Count scrolls by element type
                const scrollCounts = { earth: 0, water: 0, fire: 0, wind: 0, void: 0, catacomb: 0 };
                playerScrollData.collected.forEach(scrollName => {
                    const element = scrollName.split('_')[0].toLowerCase();
                    if (scrollCounts[element] !== undefined) {
                        scrollCounts[element]++;
                    }
                });

                // Display scroll counts
                ['earth', 'water', 'fire', 'wind', 'void'].forEach(element => {
                    if (scrollCounts[element] > 0) {
                        html += `<div class="tooltip-row">
                            <span style="color: ${elementColors[element]};">üìú ${element}:</span>
                            <span>${scrollCounts[element]}</span>
                        </div>`;
                    }
                });

                if (scrollCounts.catacomb > 0) {
                    html += `<div class="tooltip-row">
                        <span style="color: #8b4513;">üìú catacomb:</span>
                        <span>${scrollCounts.catacomb}</span>
                    </div>`;
                }

                html += `</div>`;
            }
            tooltip.innerHTML = html;

            document.body.appendChild(tooltip);
            return tooltip;
        }

        function updatePlayerElementSymbols(playerIndex = null) {
            // If no player index specified, use active player
            if (playerIndex === null) {
                playerIndex = activePlayerIndex;
            }
            
            // Find THIS player's tile
            const playerTile = placedTiles.find(t => t.isPlayerTile && t.playerIndex === playerIndex);
            if (!playerTile) {
                console.log(`No player tile found for player ${playerIndex}`);
                return;
            }

            const symbolsGroup = playerTile.element.querySelector('.player-tile-element-symbols');
            if (!symbolsGroup) return;

            // Clear existing symbols
            symbolsGroup.innerHTML = '';

            // Get activated elements for THIS specific player
            const playerScrollData = spellSystem.playerScrolls[playerIndex];
            if (!playerScrollData) return;
            
            const activatedElements = Array.from(playerScrollData.activated);
            
            if (activatedElements.length === 0) return;

            // Arrange symbols in a pentagon pattern around the tile center
            const radius = TILE_SIZE * 1.5; // Place symbols on the outer part of the tile
            const angleStep = (Math.PI * 2) / 5; // 5 elements
            const elementOrder = ['earth', 'water', 'fire', 'wind', 'void'];

            activatedElements.forEach(element => {
                const index = elementOrder.indexOf(element);
                const angle = angleStep * index - Math.PI / 2; // Start at top
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;

                // Create symbol with background circle
                const symbolBg = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                symbolBg.setAttribute('cx', x);
                symbolBg.setAttribute('cy', y);
                symbolBg.setAttribute('r', '18');
                symbolBg.setAttribute('fill', STONE_TYPES[element].color);
                symbolBg.setAttribute('stroke', '#fff');
                symbolBg.setAttribute('stroke-width', '2');
                symbolsGroup.appendChild(symbolBg);

                // Create symbol
                const symbol = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                symbol.setAttribute('x', x);
                symbol.setAttribute('y', y);
                symbol.setAttribute('text-anchor', 'middle');
                symbol.setAttribute('dominant-baseline', 'middle');
                symbol.setAttribute('fill', '#fff');
                symbol.setAttribute('font-size', '20');
                symbol.setAttribute('font-weight', 'bold');
                symbol.setAttribute('stroke', '#000');
                symbol.setAttribute('stroke-width', '0.5');
                symbol.textContent = STONE_TYPES[element].symbol;

                symbolsGroup.appendChild(symbol);
            });

            console.log(`üé® Updated player ${playerIndex}'s TILE with ${activatedElements.length} element symbol(s): ${activatedElements.join(', ')}`);
        }

        function startPlayerDrag(e) {
            // Check if it's this player's turn
            if (!isMyTurn()) {
                notYourTurn();
                return;
            }

            isDraggingPlayer = true;
            playerPath = [{ x: playerPosition.x, y: playerPosition.y, cost: 0 }];
            lastAttemptedHex = null; // Reset logging state
            playerPosition.element.remove();

            const rect = boardSvg.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            const world = screenToWorld(screenX, screenY);

            ghostPlayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            ghostPlayer.setAttribute('class', 'player stone-ghost');
            ghostPlayer.setAttribute('transform', `translate(${world.x}, ${world.y})`);

            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', 0);
            circle.setAttribute('cy', 0);
            circle.setAttribute('r', TILE_SIZE * 0.4);
            circle.setAttribute('class', 'player-marker');

            ghostPlayer.appendChild(circle);
            viewport.appendChild(ghostPlayer);

            // Create path line
            pathLine = document.createElementNS('http://www.w3.org/2000/svg', 'polyline');
            pathLine.setAttribute('id', 'player-path');
            pathLine.setAttribute('fill', 'none');
            pathLine.setAttribute('stroke', '#58a4f4');
            pathLine.setAttribute('stroke-width', '3');
            pathLine.setAttribute('stroke-dasharray', '5,5');
            pathLine.setAttribute('opacity', '0.7');
            viewport.insertBefore(pathLine, ghostPlayer);
        }

        let lastAttemptedHex = null;

        // Find if target is reachable through a chain of wind stones/water-with-wind
        function findWindPath(startX, startY, targetX, targetY) {
            // BFS to find path through wind stones
            const queue = [{x: startX, y: startY, path: []}];
            const visited = new Set();
            visited.add(`${startX.toFixed(1)},${startY.toFixed(1)}`);

            while (queue.length > 0) {
                const current = queue.shift();

                // Get all wind stones and water-with-wind adjacent to current position
                const windStones = getAdjacentWindStones(current.x, current.y);

                // Also check water with chained wind
                const neighbors = getNeighborStones(current.x, current.y);
                const waterWithWind = neighbors.filter(n => {
                    if (n.type !== 'water') return false;
                    const chainedAbility = getChainedAbility(n.x, n.y);
                    return chainedAbility === 'wind';
                });

                const allWindSources = [...windStones, ...waterWithWind];

                for (const windSource of allWindSources) {
                    const key = `${windSource.x.toFixed(1)},${windSource.y.toFixed(1)}`;

                    // Skip if nullified by void
                    const hasVoid = hasAdjacentStoneType(windSource.x, windSource.y, 'void');
                    if (hasVoid) continue;

                    // Check if target is adjacent to this wind source
                    const windNeighbors = getNeighborHexPositions(windSource.x, windSource.y);
                    const canReachTarget = windNeighbors.some(n =>
                        Math.sqrt(Math.pow(n.x - targetX, 2) + Math.pow(n.y - targetY, 2)) < 5
                    );

                    if (canReachTarget) {
                        // Found a path!
                        return [...current.path, windSource];
                    }

                    // Continue searching through this wind source
                    if (!visited.has(key)) {
                        visited.add(key);
                        queue.push({
                            x: windSource.x,
                            y: windSource.y,
                            path: [...current.path, windSource]
                        });
                    }
                }
            }

            return null; // No path found
        }

        function findGeneralPath(startX, startY, targetX, targetY, maxCost) {
            // A* pathfinding to find cheapest path through any hex
            const openSet = [{x: startX, y: startY, path: [], cost: 0, priority: 0}];
            const visited = new Map();

            while (openSet.length > 0) {
                // Get node with lowest priority (cost + heuristic)
                openSet.sort((a, b) => a.priority - b.priority);
                const current = openSet.shift();

                const key = `${current.x.toFixed(1)},${current.y.toFixed(1)}`;

                // Skip if we've visited this with lower cost
                if (visited.has(key) && visited.get(key) <= current.cost) continue;
                visited.set(key, current.cost);

                // Check if we reached the target
                const distToTarget = Math.sqrt(Math.pow(current.x - targetX, 2) + Math.pow(current.y - targetY, 2));
                if (distToTarget < 5) {
                    return { path: current.path, cost: current.cost };
                }

                // Explore neighbors
                const neighbors = getNeighborHexPositions(current.x, current.y);
                for (const neighbor of neighbors) {
                    const moveCheck = canPlayerMoveToHex(neighbor.x, neighbor.y);

                    if (moveCheck.canMove) {
                        const newCost = current.cost + moveCheck.cost;

                        // Skip if would exceed max cost
                        if (newCost > maxCost) continue;

                        const neighborKey = `${neighbor.x.toFixed(1)},${neighbor.y.toFixed(1)}`;

                        // Skip if already visited with lower cost
                        if (visited.has(neighborKey) && visited.get(neighborKey) <= newCost) continue;

                        // Calculate heuristic (straight-line distance to target)
                        const heuristic = Math.sqrt(Math.pow(neighbor.x - targetX, 2) + Math.pow(neighbor.y - targetY, 2)) / TILE_SIZE;

                        openSet.push({
                            x: neighbor.x,
                            y: neighbor.y,
                            path: [...current.path, {x: neighbor.x, y: neighbor.y, cost: moveCheck.cost}],
                            cost: newCost,
                            priority: newCost + heuristic
                        });
                    }
                }
            }

            return null; // No path found
        }

        function getAdjacentWindStones(x, y) {
            const neighbors = getNeighborHexPositions(x, y);
            const windStones = [];

            neighbors.forEach(neighborPos => {
                const stone = placedStones.find(s => {
                    const dist = Math.sqrt(Math.pow(s.x - neighborPos.x, 2) + Math.pow(s.y - neighborPos.y, 2));
                    if (dist >= 5) return false;

                    // Check if it's wind or water mimicking wind
                    const effectiveType = getEffectiveStoneType(s);
                    return effectiveType === 'wind';
                });
                if (stone) {
                    windStones.push(stone);
                }
            });

            return windStones;
        }

        function getAdjacentEarthStones(x, y) {
            const neighbors = getNeighborHexPositions(x, y);
            const earthStones = [];

            neighbors.forEach(neighborPos => {
                const stone = placedStones.find(s => {
                    const dist = Math.sqrt(Math.pow(s.x - neighborPos.x, 2) + Math.pow(s.y - neighborPos.y, 2));
                    if (dist >= 5) return false;

                    // Check if it's earth or water mimicking earth
                    const effectiveType = getEffectiveStoneType(s);
                    return effectiveType === 'earth';
                });
                if (stone) {
                    earthStones.push(stone);
                }
            });

            return earthStones;
        }

        // Get the chained ability for a water stone by flood-filling through connected water
        function getChainedAbility(x, y) {
            // Only water stones can receive chained abilities
            const stone = placedStones.find(s => {
                const dist = Math.sqrt(Math.pow(s.x - x, 2) + Math.pow(s.y - y, 2));
                return dist < 5;
            });

            if (!stone || stone.type !== 'water') {
                return null; // Not a water stone
            }

            // Check if THIS water stone is nullified by void
            const waterNullified = hasAdjacentStoneType(x, y, 'void');
            if (waterNullified) {
                return null; // Water's chaining ability is nullified by adjacent void
            }

            // Flood fill through connected water to find wind/earth sources
            const visited = new Set();
            const queue = [{x, y}];
            visited.add(`${x.toFixed(1)},${y.toFixed(1)}`);

            let hasWind = false;
            let hasEarth = false;

            while (queue.length > 0) {
                const current = queue.shift();
                const neighbors = getNeighborStones(current.x, current.y);

                for (const neighbor of neighbors) {
                    const key = `${neighbor.x.toFixed(1)},${neighbor.y.toFixed(1)}`;

                    // Check if this neighbor is a source stone (wind or earth, not nullified by void)
                    if (neighbor.type === 'wind') {
                        const voidNullified = hasAdjacentStoneType(neighbor.x, neighbor.y, 'void');
                        if (!voidNullified) {
                            hasWind = true;
                        }
                    } else if (neighbor.type === 'earth') {
                        const voidNullified = hasAdjacentStoneType(neighbor.x, neighbor.y, 'void');
                        if (!voidNullified) {
                            hasEarth = true;
                        }
                    }

                    // If neighbor is water and not visited, add to queue to continue flood fill
                    if (neighbor.type === 'water' && !visited.has(key)) {
                        // Check if this water is nullified by void
                        const neighborWaterNullified = hasAdjacentStoneType(neighbor.x, neighbor.y, 'void');
                        if (!neighborWaterNullified) {
                            visited.add(key);
                            queue.push({x: neighbor.x, y: neighbor.y});
                        }
                    }
                }
            }

            // Wind outranks earth
            if (hasWind) return 'wind';
            if (hasEarth) return 'earth';
            return null; // No chained ability
        }

        function updatePlayerPath(x, y) {
            const lastPos = playerPath[playerPath.length - 1];
            if (!lastPos) return;

            // Only consider the 6 neighbors of the last hex for path extension.
            // This avoids "zig-zag" selection when zoomed out (small cursor movements map to big world deltas).
            const neighbors = getNeighborHexPositions(lastPos.x, lastPos.y);

            // Dynamic direction bias: stronger when zoomed out.
            // viewportScale is the world->screen scale (smaller = more zoomed out).
            const scale = (typeof viewportScale === 'number' && isFinite(viewportScale)) ? viewportScale : 1;
            const directionWeight = Math.min(TILE_SIZE * 1.2, (TILE_SIZE * 0.6) / Math.max(0.25, scale));

            let prevVec = null;
            if (playerPath.length >= 2) {
                const prevPos = playerPath[playerPath.length - 2];
                prevVec = { x: lastPos.x - prevPos.x, y: lastPos.y - prevPos.y };
            }

            let best = null;
            let bestScore = Infinity;

            for (const n of neighbors) {
                const dx = x - n.x;
                const dy = y - n.y;
                const distToCursor = Math.hypot(dx, dy);

                // Basic snap radius (world-space). Keep generous, but selection is stabilized by scoring.
                if (distToCursor > TILE_SIZE * 1.6) continue;

                let anglePenalty = 0;
                if (prevVec) {
                    const candVec = { x: n.x - lastPos.x, y: n.y - lastPos.y };
                    const aLen = Math.hypot(prevVec.x, prevVec.y);
                    const bLen = Math.hypot(candVec.x, candVec.y);
                    if (aLen > 0.0001 && bLen > 0.0001) {
                        const dot = (prevVec.x * candVec.x + prevVec.y * candVec.y) / (aLen * bLen);
                        const clamped = Math.max(-1, Math.min(1, dot));
                        const angle = Math.acos(clamped); // 0 = straight, PI = reverse
                        anglePenalty = angle;
                    }
                }

                // Score: prefer closer-to-cursor, with a gentle bias to continue straight.
                const score = distToCursor + (directionWeight * anglePenalty);
                if (score < bestScore) {
                    bestScore = score;
                    best = n;
                }
            }

            if (!best) return;

            // If the cursor is still basically on the current hex, don't add.
            const isDifferentHex = Math.hypot(best.x - lastPos.x, best.y - lastPos.y) > 5;
            if (!isDifferentHex) return;

            // Only log once per hex attempt
            const hexKey = `${best.x.toFixed(1)},${best.y.toFixed(1)}`;
            const shouldLog = hexKey !== lastAttemptedHex;
            if (shouldLog) lastAttemptedHex = hexKey;

            const moveCheck = canPlayerMoveToHex(best.x, best.y, shouldLog);
            if (shouldLog) {
                console.log(`üéØ Attempting to add hex (${best.x.toFixed(1)}, ${best.y.toFixed(1)}): canMove=${moveCheck.canMove}, cost=${moveCheck.cost}`);
            }

            if (moveCheck.canMove) {
                const totalCost = calculatePathCost();
                if (totalCost + moveCheck.cost <= getTotalAP()) {
                    playerPath.push({ x: best.x, y: best.y, cost: moveCheck.cost });
                    if (shouldLog) {
                        console.log(`‚úÖ Added to path! Total cost now: ${totalCost + moveCheck.cost}`);
                    }
                } else if (shouldLog) {
                    console.log(`‚ö†Ô∏è Cannot extend path to (${best.x.toFixed(1)}, ${best.y.toFixed(1)}): Insufficient AP (need ${totalCost + moveCheck.cost}, have ${getTotalAP()})`);
                }
            } else if (shouldLog) {
                console.log(`‚ö†Ô∏è Cannot extend path to (${best.x.toFixed(1)}, ${best.y.toFixed(1)}): Blocked`);
            }

            // Update path line

            if (pathLine && playerPath.length > 1) {
                const points = playerPath.map(p => `${p.x},${p.y}`).join(' ');
                pathLine.setAttribute('points', points);
            } else if (pathLine) {
                pathLine.setAttribute('points', '');
            }


            // Update AP cost labels
            updatePathLabels();
        }

        function updatePathLabels() {
            // Remove old labels
            pathCostLabels.forEach(label => label.remove());
            pathCostLabels = [];

            if (playerPath.length < 2) return;

            // Calculate cumulative costs and remaining AP for each segment
            let cumulativeCost = 0;

            for (let i = 1; i < playerPath.length; i++) {
                const currentSegment = playerPath[i];
                cumulativeCost += currentSegment.cost;
                const remainingAP = currentAP - cumulativeCost;

                // Calculate midpoint between this segment and previous
                const prevSegment = playerPath[i - 1];
                const midX = (currentSegment.x + prevSegment.x) / 2;
                const midY = (currentSegment.y + prevSegment.y) / 2;

                // Create label
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', midX);
                label.setAttribute('y', midY - 8); // Offset above the line
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('fill', remainingAP >= 0 ? '#2ecc71' : '#e74c3c');
                label.setAttribute('font-size', '14');
                label.setAttribute('font-weight', 'bold');
                label.setAttribute('stroke', '#000');
                label.setAttribute('stroke-width', '0.5');
                label.setAttribute('paint-order', 'stroke');
                label.textContent = remainingAP;

                viewport.appendChild(label);
                pathCostLabels.push(label);
            }
        }

        function getNeighborHexPositions(x, y) {
            const neighbors = [];
            const s = TILE_SIZE;
            const dirs = [
                { q: 1, r: 0 }, { q: 1, r: -1 }, { q: 0, r: -1 },
                { q: -1, r: 0 }, { q: -1, r: 1 }, { q: 0, r: 1 }
            ];

            for (const dir of dirs) {
                const pos = hexToPixel(dir.q, dir.r, s);
                neighbors.push({ x: x + pos.x, y: y + pos.y });
            }
            return neighbors;
        }

        function calculatePathCost() {
            let totalCost = 0;
            for (let i = 1; i < playerPath.length; i++) {
                totalCost += playerPath[i].cost;
            }
            return totalCost;
        }

        let nextStoneId = 1; // Global counter for unique stone IDs

        function placeStone(x, y, type) {
            const stoneId = nextStoneId++;
            console.log(`   Placing stone: id=${stoneId}, type=${type}, position=(${x.toFixed(1)}, ${y.toFixed(1)})`);

            // Broadcast stone placement to other players
            broadcastGameAction('stone-place', {
                x: x,
                y: y,
                stoneType: type
            });

            const stoneGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            stoneGroup.setAttribute('class', 'stone');
            stoneGroup.setAttribute('data-stone-id', stoneId);
            stoneGroup.setAttribute('transform', `translate(${x}, ${y})`);

            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', 0);
            circle.setAttribute('cy', 0);
            circle.setAttribute('r', STONE_SIZE);
            circle.setAttribute('class', 'stone-piece');
            circle.setAttribute('fill', STONE_TYPES[type].color);

            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', 0);
            text.setAttribute('y', 0);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('dominant-baseline', 'middle');
            text.setAttribute('fill', '#fff');
            text.setAttribute('font-size', '14');
            text.setAttribute('font-weight', 'bold');
            text.textContent = STONE_TYPES[type].symbol;

            stoneGroup.appendChild(circle);
            stoneGroup.appendChild(text);

            stoneGroup.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                e.preventDefault();
                // Stone dragging disabled - stones can only be placed from pool or broken (right-click)
                updateStatus('üí° Right-click to break this stone (costs AP based on rank)');
            });

            // Touch support: long-press to break stone
            stoneGroup.addEventListener('touchstart', (e) => {
                e.stopPropagation();
                e.preventDefault();
                updateStatus('üí° Long-press to break this stone (costs AP based on rank)');
                clearTimeout(stoneLongPressTimer);
                stoneLongPressTimer = setTimeout(() => {
                    attemptBreakStone(stoneId);
                }, 650);
            }, { passive: false });

            stoneGroup.addEventListener('touchend', (e) => {
                clearTimeout(stoneLongPressTimer);
                stoneLongPressTimer = null;
            });

            stoneGroup.addEventListener('contextmenu', (e) => {
                e.stopPropagation();
                e.preventDefault();
                attemptBreakStone(stoneId);
            });

            stoneGroup.addEventListener('mouseenter', (e) => {
                e.stopPropagation();
                
                // Check if stone is adjacent to player and show break cost
                const stone = placedStones.find(s => s.id === stoneId);
                if (stone && playerPosition && isAdjacentToPlayer(stone.x, stone.y)) {
                    const STONE_RANK = { 'void': 1, 'wind': 2, 'fire': 3, 'water': 4, 'earth': 5 };
                    const breakCost = STONE_RANK[stone.type];
                    const canAffordBreak = getTotalAP() >= breakCost;
                    
                    stoneGroup.style.cursor = 'pointer';
                    stoneGroup.style.filter = canAffordBreak ? 'brightness(1.3)' : 'brightness(0.7)';
                    
                    updateStatus(`Right-click to break ${stone.type} stone (${breakCost} AP)${canAffordBreak ? '' : ' - Not enough AP!'}`);
                }
            });

            stoneGroup.addEventListener('mouseleave', (e) => {
                e.stopPropagation();
                stoneGroup.style.filter = '';
            });

            viewport.appendChild(stoneGroup);

            placedStones.push({
                id: stoneId,
                x: x,
                y: y,
                type: type,
                element: stoneGroup
            });

            updateTileClasses();
            processStoneInteractions(x, y, type);

            // Re-check all fire stones in case void was moved away
            recheckAllStoneInteractions();

            // Update visuals for all water stones (mimicry indicators)
            updateAllWaterStoneVisuals();

            // Update void nullification indicators
            updateAllVoidNullificationVisuals();

            return stoneId;
        }

        // Visual-only stone placement (called when receiving broadcast from other players)
        function placeStoneVisually(x, y, stoneType) {
            // Same logic as placeStone but without broadcasting
            const stoneId = nextStoneId++;
            const stoneGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            stoneGroup.setAttribute('class', 'stone');
            stoneGroup.setAttribute('data-stone-id', stoneId);
            stoneGroup.setAttribute('transform', `translate(${x}, ${y})`);

            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', 0);
            circle.setAttribute('cy', 0);
            circle.setAttribute('r', STONE_SIZE);
            circle.setAttribute('class', 'stone-piece');
            circle.setAttribute('fill', STONE_TYPES[stoneType].color);

            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', 0);
            text.setAttribute('y', 0);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('dominant-baseline', 'middle');
            text.setAttribute('fill', '#fff');
            text.setAttribute('font-size', '14');
            text.setAttribute('font-weight', 'bold');
            text.textContent = STONE_TYPES[stoneType].symbol;

            stoneGroup.appendChild(circle);
            stoneGroup.appendChild(text);

            stoneGroup.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                e.preventDefault();
                updateStatus('üí° Right-click to break this stone (costs AP based on rank)');
            });

            // Touch support: long-press to break stone
            stoneGroup.addEventListener('touchstart', (e) => {
                e.stopPropagation();
                e.preventDefault();
                updateStatus('üí° Long-press to break this stone (costs AP based on rank)');
                clearTimeout(stoneLongPressTimer);
                stoneLongPressTimer = setTimeout(() => {
                    attemptBreakStone(stoneId);
                }, 650);
            }, { passive: false });

            stoneGroup.addEventListener('touchend', (e) => {
                clearTimeout(stoneLongPressTimer);
                stoneLongPressTimer = null;
            });

            stoneGroup.addEventListener('contextmenu', (e) => {
                e.stopPropagation();
                e.preventDefault();
                attemptBreakStone(stoneId);
            });

            viewport.appendChild(stoneGroup);

            placedStones.push({
                id: stoneId,
                x: x,
                y: y,
                type: stoneType,
                element: stoneGroup
            });

            updateTileClasses();
            processStoneInteractions(x, y, stoneType);
            recheckAllStoneInteractions();
            updateAllWaterStoneVisuals();
            updateAllVoidNullificationVisuals();
        }

        function updateAllWaterStoneVisuals() {
            // Update all water stones to show what they're mimicking
            placedStones.forEach(stone => {
                if (stone.type === 'water') {
                    updateWaterStoneVisual(stone);
                }
            });
        }

        function updateAllVoidNullificationVisuals() {
            // Update all stones to show if they're nullified by void
            placedStones.forEach(stone => {
                // Remove any existing nullification indicator
                const existingNullIndicator = stone.element.querySelector('.void-nullification-indicator');
                if (existingNullIndicator) {
                    existingNullIndicator.remove();
                }

                // Check if this stone is nullified by adjacent void
                // (Only fire, wind, and earth have abilities that can be nullified)
                if (stone.type === 'fire' || stone.type === 'wind' || stone.type === 'earth') {
                    const hasVoid = hasAdjacentStoneType(stone.x, stone.y, 'void');
                    if (hasVoid) {
                        // Add nullification indicator (X or crossed-out effect)
                        const nullIndicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        nullIndicator.setAttribute('cx', 0);
                        nullIndicator.setAttribute('cy', 0);
                        nullIndicator.setAttribute('r', STONE_SIZE + 3);
                        nullIndicator.setAttribute('class', 'void-nullification-indicator');
                        nullIndicator.setAttribute('fill', 'none');
                        nullIndicator.setAttribute('stroke', STONE_TYPES['void'].color);
                        nullIndicator.setAttribute('stroke-width', '2');
                        nullIndicator.setAttribute('stroke-dasharray', '2,2');
                        nullIndicator.setAttribute('opacity', '0.6');

                        // Insert before other elements
                        stone.element.insertBefore(nullIndicator, stone.element.firstChild);

                        console.log(`‚ú® ${stone.type} at (${stone.x.toFixed(1)}, ${stone.y.toFixed(1)}) is nullified by void`);
                    }
                }
            });
        }

        function updateWaterStoneVisual(waterStone) {
            const effectiveType = getEffectiveStoneType(waterStone);
            const chainedAbility = getChainedAbility(waterStone.x, waterStone.y);

            // Remove any existing indicators
            const existingIndicator = waterStone.element.querySelector('.mimicry-indicator');
            if (existingIndicator) {
                existingIndicator.remove();
            }
            const existingChainIndicator = waterStone.element.querySelector('.chain-indicator');
            if (existingChainIndicator) {
                existingChainIndicator.remove();
            }

            // Determine what to show: chained ability takes precedence over mimicry
            // because chaining uses wind-outranks-earth logic
            const displayAbility = chainedAbility || (effectiveType !== 'water' ? effectiveType : null);

            if (displayAbility) {
                const isChained = !!chainedAbility;
                const indicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                indicator.setAttribute('cx', 0);
                indicator.setAttribute('cy', 0);
                indicator.setAttribute('r', STONE_SIZE + 3);
                indicator.setAttribute('class', isChained ? 'chain-indicator' : 'mimicry-indicator');
                indicator.setAttribute('fill', 'none');
                indicator.setAttribute('stroke', STONE_TYPES[displayAbility].color);
                indicator.setAttribute('stroke-width', '2');
                indicator.setAttribute('stroke-dasharray', isChained ? '5,2' : '3,3');
                if (isChained) {
                    indicator.setAttribute('opacity', '0.7');
                }

                // Insert before other elements
                waterStone.element.insertBefore(indicator, waterStone.element.firstChild);

                if (isChained) {
                    console.log(`üîó Water at (${waterStone.x.toFixed(1)}, ${waterStone.y.toFixed(1)}) has chained ${displayAbility} ability`);
                } else {
                    console.log(`üíß Water at (${waterStone.x.toFixed(1)}, ${waterStone.y.toFixed(1)}) is mimicking ${displayAbility}`);
                }
            }
        }

        function getNeighborStones(x, y) {
            const neighbors = [];
            const hexPositions = getAllHexagonPositions();

            hexPositions.forEach(pos => {
                const dist = Math.sqrt(Math.pow(x - pos.x, 2) + Math.pow(y - pos.y, 2));
                if (dist > 5 && dist < TILE_SIZE * 2.5) {
                    const stone = placedStones.find(s => {
                        const stoneDist = Math.sqrt(Math.pow(s.x - pos.x, 2) + Math.pow(s.y - pos.y, 2));
                        return stoneDist < 5;
                    });
                    if (stone) {
                        neighbors.push(stone);
                    }
                }
            });

            return neighbors;
        }

        function hasAdjacentStoneType(x, y, type) {
            const neighbors = getNeighborStones(x, y);
            return neighbors.some(s => s.type === type);
        }

        // Stone rank for water mimicry priority (lower = higher priority)
        const STONE_RANK = {
            'void': 1,
            'wind': 2,
            'fire': 3,
            'water': 4,
            'earth': 5
        };

        // Get the effective type of a stone (considering water mimicry)
        function getEffectiveStoneType(stone) {
            if (stone.type !== 'water') {
                return stone.type;
            }

            // Water mimics adjacent stones
            const neighbors = getNeighborStones(stone.x, stone.y);
            if (neighbors.length === 0) {
                return 'water'; // No neighbors, just water
            }

            // Find highest-ranked adjacent stone (lowest rank number)
            let bestRank = Infinity;
            let mimicType = 'water';

            neighbors.forEach(neighbor => {
                const rank = STONE_RANK[neighbor.type] || 999;
                if (rank < bestRank && neighbor.type !== 'water') {
                    bestRank = rank;
                    mimicType = neighbor.type;
                }
            });

            return mimicType;
        }

        function recheckAllStoneInteractions() {
            // Re-check interactions for all fire stones on the board
            // This ensures fire destroys adjacent stones when void is removed
            const fireStones = placedStones.filter(s => s.type === 'fire');

            fireStones.forEach(stone => {
                const fireHasVoid = hasAdjacentStoneType(stone.x, stone.y, 'void');
                if (!fireHasVoid) {
                    // Fire is not nullified, check what it should destroy
                    const neighbors = getNeighborStones(stone.x, stone.y);
                    const stonesToDestroy = [];
                    neighbors.forEach(neighbor => {
                        // Fire destroys ALL stones except void and fire
                        // (Water is NOT protected - fire destroys water)
                        if (neighbor.type !== 'void' && neighbor.type !== 'fire') {
                            stonesToDestroy.push(neighbor.id);
                        }
                    });

                    // Destroy adjacent stones (using direct removal to avoid recursion)
                    stonesToDestroy.forEach(targetId => {
                        const target = placedStones.find(s => s.id === targetId);
                        if (target) {
                            target.element.remove();
                            placedStones = placedStones.filter(s => s.id !== targetId);
                            returnStoneToPool(target.type);
                            updateStatus(`Fire destroyed ${target.type} stone!`);
                        }
                    });
                }
            });
        }

        function processStoneInteractions(x, y, type) {
            const neighbors = getNeighborStones(x, y);

            // Special case: water stone placed with both fire and a higher-priority stone
            // Water mimics the higher-priority stone, then gets destroyed by fire
            if (type === 'water') {
                const hasFire = neighbors.some(n => n.type === 'fire');
                if (hasFire) {
                    // Check what the water would mimic
                    const effectiveType = getEffectiveStoneType({ x, y, type: 'water' });
                    // If water is mimicking something other than water or fire, it gets destroyed
                    if (effectiveType !== 'water' && effectiveType !== 'fire') {
                        const stoneToRemove = placedStones.find(s => s.x === x && s.y === y);
                        if (stoneToRemove) {
                            setTimeout(() => {
                                removeStone(stoneToRemove.id);
                                updateStatus(`Water mimicked ${effectiveType}, then was destroyed by fire!`);
                            }, 100);
                        }
                        return; // Stop processing other interactions
                    }
                }
            }

            // Fire destroys adjacent non-void, non-fire stones
            // But only if fire itself is not nullified by an adjacent void
            if (type === 'fire') {
                const fireHasVoid = hasAdjacentStoneType(x, y, 'void');

                if (!fireHasVoid) {
                    const stonesToDestroy = [];
                    neighbors.forEach(neighbor => {
                        // Don't destroy void or fire
                        // Fire destroys ALL other stones, even if they're voided
                        if (neighbor.type !== 'void' && neighbor.type !== 'fire') {
                            stonesToDestroy.push(neighbor);
                        }
                    });

                    // Destroy all adjacent stones (voided or not)
                    stonesToDestroy.forEach(stone => {
                        removeStone(stone.id);
                        updateStatus(`Fire destroyed ${stone.type} stone!`);
                    });
                }
            }

            // Fire also checks incoming threats
            neighbors.forEach(neighbor => {
                if (neighbor.type === 'fire' && type !== 'void' && type !== 'fire') {
                    const hasVoid = hasAdjacentStoneType(neighbor.x, neighbor.y, 'void');
                    if (!hasVoid) {
                        const stoneToRemove = placedStones.find(s => s.x === x && s.y === y);
                        if (stoneToRemove) {
                            removeStone(stoneToRemove.id);
                            updateStatus(`Fire destroyed ${type} stone!`);
                        }
                    }
                }
            });
        }

        function removeStone(stoneId) {
            const stone = placedStones.find(s => s.id === stoneId);
            if (stone) {
                stone.element.remove();
                placedStones = placedStones.filter(s => s.id !== stoneId);
                returnStoneToPool(stone.type);
                updateTileClasses();

                // Re-check all fire stones to see if they should activate
                recheckAllStoneInteractions();

                // Update all water stone visuals since chaining may have changed
                updateAllWaterStoneVisuals();

                // Update void nullification indicators
                updateAllVoidNullificationVisuals();
            }
        }

        
        function isHexOccupiedByOtherPlayer(x, y) {
            if (!Array.isArray(playerPositions) || typeof activePlayerIndex !== 'number') return false;
            return playerPositions.some((p, idx) => {
                if (!p) return false;
                if (idx === activePlayerIndex) return false; // ignore self
                const dist = Math.hypot(p.x - x, p.y - y);
                return dist < 5; // same positional threshold used elsewhere
            });
        }

        function canPlayerMoveToHex(x, y, logBlocked = false) {
            // Block movement onto hexes occupied by other players (prevents moving "through" players as pathing is step-wise)
            if (isHexOccupiedByOtherPlayer(x, y)) {
                if (logBlocked) console.log(`‚ùå Cannot move to (${x.toFixed(1)}, ${y.toFixed(1)}): occupied by another player`);
                return { canMove: false, cost: Infinity };
            }

            const stone = placedStones.find(s => {
                const dist = Math.sqrt(Math.pow(s.x - x, 2) + Math.pow(s.y - y, 2));
                return dist < 5;
            });

            if (!stone) return { canMove: true, cost: 1 };

            // Handle water stones with chaining
            if (stone.type === 'water') {
                const chainedAbility = getChainedAbility(x, y);
                console.log(`üíß Water at (${x.toFixed(1)}, ${y.toFixed(1)}) has chained ability: ${chainedAbility || 'none'}`);

                if (chainedAbility === 'wind') {
                    // Wind chains through water - free movement
                    console.log(`‚úì Wind chaining active - water becomes free movement`);
                    return { canMove: true, cost: 0 };
                } else if (chainedAbility === 'earth') {
                    // Earth chains through water - blocks movement
                    console.log(`‚úì Earth chaining active - water blocks movement`);
                    if (logBlocked) console.log(`‚ùå Cannot move to (${x.toFixed(1)}, ${y.toFixed(1)}): Water has chained Earth ability (blocks movement)`);
                    return { canMove: false, cost: Infinity };
                }

                // No chaining effects, normal water cost
                console.log(`üíß No chaining - normal water cost (2 AP)`);
                return { canMove: true, cost: 2 };
            }

            // Handle non-water stones based on their ACTUAL type, not mimicry
            // (Mimicry is visual only, doesn't affect movement)

            // Earth blocks movement (unless nullified by void)
            if (stone.type === 'earth') {
                const hasVoid = hasAdjacentStoneType(x, y, 'void');
                if (hasVoid) return { canMove: true, cost: 1 }; // Nullified by void, reverts to baseline
                if (logBlocked) console.log(`‚ùå Cannot move to (${x.toFixed(1)}, ${y.toFixed(1)}): Earth stone blocks movement (needs adjacent Void to nullify)`);
                return { canMove: false, cost: Infinity };
            }

            // Wind is free (0 cost) - ability overrides baseline
            if (stone.type === 'wind') {
                const hasVoid = hasAdjacentStoneType(x, y, 'void');
                if (hasVoid) return { canMove: true, cost: 1 }; // Nullified by void, reverts to baseline
                return { canMove: true, cost: 0 }; // Wind ability: free movement
            }

            // All other stones (void, fire, etc.) cost 1 AP (baseline)
            return { canMove: true, cost: 1 };
        }

        function startStoneDrag(stoneId, e) {
            // Check if it's this player's turn
            if (!isMyTurn()) {
                notYourTurn();
                return;
            }

            const stone = placedStones.find(s => s.id === stoneId);
            if (!stone) {
                console.log('‚ùå Stone not found for dragging');
                return;
            }

            // Check if stone is adjacent to player
            if (!playerPosition) {
                updateStatus('‚ùå No player on board!');
                return;
            }

            if (!isAdjacentToPlayer(stone.x, stone.y)) {
                updateStatus('‚ùå Can only move stones adjacent to player!');
                console.log(`‚ùå Cannot drag stone id=${stoneId}: not adjacent to player`);
                return;
            }

            console.log(`‚úÖ Starting drag for stone id=${stoneId}, type=${stone.type} (adjacent to player)`);

            isDraggingStone = true;
            draggedStoneId = stoneId;
            draggedStoneType = stone.type;
            stone.element.remove();
            placedStones = placedStones.filter(s => s.id !== stoneId);
            updateTileClasses();

            // Re-check all fire stones to see if they should activate/deactivate
            recheckAllStoneInteractions();

            // Update all water stone visuals since chaining may have changed
            updateAllWaterStoneVisuals();

            // Update void nullification indicators
            updateAllVoidNullificationVisuals();

            const rect = boardSvg.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            const world = screenToWorld(screenX, screenY);

            ghostStone = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            ghostStone.setAttribute('class', 'stone stone-ghost');
            ghostStone.setAttribute('transform', `translate(${world.x}, ${world.y})`);

            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', 0);
            circle.setAttribute('cy', 0);
            circle.setAttribute('r', STONE_SIZE);
            circle.setAttribute('class', 'stone-piece');
            circle.setAttribute('fill', STONE_TYPES[draggedStoneType].color);

            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', 0);
            text.setAttribute('y', 0);
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('dominant-baseline', 'middle');
            text.setAttribute('fill', '#fff');
            text.setAttribute('font-size', '14');
            text.setAttribute('font-weight', 'bold');
            text.textContent = STONE_TYPES[draggedStoneType].symbol;

            ghostStone.appendChild(circle);
            ghostStone.appendChild(text);
            viewport.appendChild(ghostStone);
        }

        function updateStoneCount(type) {
            document.getElementById(type + '-count').textContent = stoneCounts[type] + '/' + stoneCapacity[type];
            updateSourceCount(type);
            
            // Update void AP whenever void stones change
            if (type === 'void') {
                console.log(`üìä Void stones changed to ${playerPool.void}, updating void AP to match`);
                updateVoidAP();
            }
        }

        function updateSourceCount(type) {
            document.getElementById(type + '-source').textContent = 'Source: ' + sourcePool[type] + '/' + sourcePoolCapacity[type];
        }

        function returnStoneToPool(type) {
            // Return a stone to the SOURCE pool (not player pool)
            // This happens when stones are removed from board or destroyed
            const maxStones = sourcePoolCapacity[type];
            if (sourcePool[type] < maxStones) {
                sourcePool[type]++;
                updateSourceCount(type);
                console.log(`‚ôªÔ∏è Returned ${type} stone to source pool (${sourcePool[type]}/${maxStones})`);
            } else {
                console.log(`‚ö†Ô∏è Cannot return ${type} stone to source pool: already at maximum (${maxStones})`);
            }
        }

        function updateStatus(msg) {
            document.getElementById('status').textContent = msg;
        }

        function clearBoard(skipConfirm = false) {
            if (!skipConfirm && !confirm('Clear all tiles and stones from the board?')) {
                return;
            }
            
            placedTiles.forEach(tile => tile.element.remove());
            placedStones.forEach(stone => stone.element.remove());
            
            // Clear all player pawns
            playerPositions.forEach(player => {
                if (player && player.element) player.element.remove();
            });
            
            placedTiles = [];
            placedStones = [];
            playerPositions = [];
            activePlayerIndex = 0;
            updateStatus('Board cleared');
        }

        // Event Handlers - Tile Deck
        deckTileSvg.addEventListener('mousedown', (e) => {
            if (e.button === 2) {
                e.preventDefault();
                isRotatingTile = true;
                rotateTileStartX = e.clientX;
                rotateTileStartRotation = currentRotation;
                return;
            }

            isDraggingTile = true;
            draggedTileId = null;
            draggedTileRotation = currentRotation;
            draggedTileFlipped = currentFlipped;
            draggedTileShrineType = null; // Draw from deck
            const rect = boardSvg.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            const world = screenToWorld(screenX, screenY);

            ghostTile = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            ghostTile.setAttribute('class', 'ghost-tile');
            ghostTile.setAttribute('transform', `translate(${world.x}, ${world.y})`);
            const tile = createTileGroup(TILE_SIZE, currentRotation, currentFlipped);
            ghostTile.appendChild(tile);
            viewport.appendChild(ghostTile);
        });

        deckTileSvg.addEventListener('contextmenu', (e) => e.preventDefault());

        // Event Handlers - Stone Decks
        ['earth', 'water', 'fire', 'wind', 'void'].forEach(type => {
            const deckElement = document.getElementById(type + '-deck');

            // Mouse handler
            deckElement.addEventListener('mousedown', (e) => {
                if (stoneCounts[type] <= 0) return;

                isDraggingStone = true;
                draggedStoneId = null;
                draggedStoneType = type;

                const rect = boardSvg.getBoundingClientRect();
                const coords = getEventCoords(e);
                const screenX = coords.x - rect.left;
                const screenY = coords.y - rect.top;
                const world = screenToWorld(screenX, screenY);

                ghostStone = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                ghostStone.setAttribute('class', 'stone stone-ghost');
                ghostStone.setAttribute('transform', `translate(${world.x}, ${world.y})`);

                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', 0);
                circle.setAttribute('cy', 0);
                circle.setAttribute('r', STONE_SIZE);
                circle.setAttribute('class', 'stone-piece');
                circle.setAttribute('fill', STONE_TYPES[type].color);

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', 0);
                text.setAttribute('y', 0);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('dominant-baseline', 'middle');
                text.setAttribute('fill', '#fff');
                text.setAttribute('font-size', '14');
                text.setAttribute('font-weight', 'bold');
                text.textContent = STONE_TYPES[type].symbol;

                ghostStone.appendChild(circle);
                ghostStone.appendChild(text);
                viewport.appendChild(ghostStone);
            });

            // Touch handler
            deckElement.addEventListener('touchstart', (e) => {
                if (stoneCounts[type] <= 0) return;
                e.preventDefault();

                isDraggingStone = true;
                draggedStoneId = null;
                draggedStoneType = type;

                const rect = boardSvg.getBoundingClientRect();
                const coords = getEventCoords(e);
                const screenX = coords.x - rect.left;
                const screenY = coords.y - rect.top;
                const world = screenToWorld(screenX, screenY);

                ghostStone = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                ghostStone.setAttribute('class', 'stone stone-ghost');
                ghostStone.setAttribute('transform', `translate(${world.x}, ${world.y})`);

                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', 0);
                circle.setAttribute('cy', 0);
                circle.setAttribute('r', STONE_SIZE);
                circle.setAttribute('class', 'stone-piece');
                circle.setAttribute('fill', STONE_TYPES[type].color);

                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', 0);
                text.setAttribute('y', 0);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('dominant-baseline', 'middle');
                text.setAttribute('fill', '#fff');
                text.setAttribute('font-size', '14');
                text.setAttribute('font-weight', 'bold');
                text.textContent = STONE_TYPES[type].symbol;

                ghostStone.appendChild(circle);
                ghostStone.appendChild(text);
                viewport.appendChild(ghostStone);
            }, { passive: false });
        });

        // Event Handlers - Board
        boardSvg.addEventListener('mousemove', (e) => {
            const rect = boardSvg.getBoundingClientRect();
            const screenX = e.clientX - rect.left;
            const screenY = e.clientY - rect.top;
            const world = screenToWorld(screenX, screenY);

            if (isDraggingTile && ghostTile) {
                const isPlayerTile = (draggedTileShrineType === 'player');
                const snapResult = findNearestSnapPoint(world.x, world.y, isPlayerTile);
                ghostTile.setAttribute('transform', `translate(${snapResult.x}, ${snapResult.y})`);

                if (snapResult.snapped) {
                    snapIndicator.setAttribute('cx', snapResult.x);
                    snapIndicator.setAttribute('cy', snapResult.y);
                    snapIndicator.classList.add('active');
                } else {
                    snapIndicator.classList.remove('active');
                }
            } else if (isDraggingStone && ghostStone) {
                const stonePos = findValidStonePosition(world.x, world.y);
                ghostStone.setAttribute('transform', `translate(${stonePos.x}, ${stonePos.y})`);

                if (stonePos.valid) {
                    snapIndicator.setAttribute('cx', stonePos.x);
                    snapIndicator.setAttribute('cy', stonePos.y);
                    snapIndicator.classList.add('active');
                } else {
                    snapIndicator.classList.remove('active');
                }
            } else if (isDraggingPlayer && ghostPlayer) {
                const playerPos = findNearestHexPosition(world.x, world.y);

                // Prevent the ghost and path preview from moving "through" other players.
                // If the nearest hex is occupied, clamp the ghost to the last valid path node.
                if (playerPos.valid && isHexOccupiedByOtherPlayer(playerPos.x, playerPos.y)) {
                    const last = (playerPath && playerPath.length) ? playerPath[playerPath.length - 1] : playerPosition;
                    ghostPlayer.setAttribute('transform', `translate(${last.x}, ${last.y})`);
                    snapIndicator.classList.remove('active');
                    updateStatus('‚ùå Blocked by another player');
                    return;
                }

                ghostPlayer.setAttribute('transform', `translate(${playerPos.x}, ${playerPos.y})`);

                if (playerPos.valid) {
                    updatePlayerPath(playerPos.x, playerPos.y);

                    const totalCost = calculatePathCost();
                    const moveCheck = canPlayerMoveToHex(playerPos.x, playerPos.y);

                    if (moveCheck.canMove && totalCost <= getTotalAP()) {
                        snapIndicator.setAttribute('cx', playerPos.x);
                        snapIndicator.setAttribute('cy', playerPos.y);
                        snapIndicator.classList.add('active');
                    } else {
                        snapIndicator.classList.remove('active');
                    }

                    // Update status with path cost
                    updateStatus(`Path cost: ${totalCost} AP (${getTotalAP() - totalCost} remaining)`);
                } else {
                    snapIndicator.classList.remove('active');
                }
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (e.button === 0) leftButtonDown = false;
            if (e.button === 2) rightButtonDown = false;

            if (isDraggingTile && ghostTile) {
                const rect = boardSvg.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                const world = screenToWorld(screenX, screenY);

                const isPlayerTile = (draggedTileShrineType === 'player');
                const snapResult = findNearestSnapPoint(world.x, world.y, isPlayerTile);
                if (snapResult.snapped) {
                    console.log(`üìç Placing tile: rotation=${draggedTileRotation}, flipped=${draggedTileFlipped}, shrine=${draggedTileShrineType}`);
                    const tileId = placeTile(snapResult.x, snapResult.y, draggedTileRotation, draggedTileFlipped, draggedTileShrineType, false, false, draggedTileId);
                    console.log(`   Tile placed with ID: ${tileId}`);

                    // If this was a player tile from the deck and it was successfully placed
                    if (draggedTileShrineType === 'player' && draggedTileId === null && tileId !== null) {
                        playerTilesAvailable--;
                        document.getElementById('player-tile-count').textContent = playerTilesAvailable;

                        // Remove the first available player tile from the deck visually
                        if (playerTileElements.length > 0) {
                            const tileToRemove = playerTileElements.shift();
                            tileToRemove.remove();
                        }

                        // Broadcast player tile placement in multiplayer
                        if (isMultiplayer) {
                            broadcastGameAction('player-tile-place', {
                                x: snapResult.x,
                                y: snapResult.y,
                                playerIndex: myPlayerIndex,
                                color: playerColor
                            });
                        }
                    }
                } else if (draggedTileId !== null && draggedTileOriginalPos) {
                    // If this was a placed tile that couldn't be re-placed, restore it to its original position
                    updateStatus('Invalid placement! Tile snapped back to original position.');
                    placeTile(draggedTileOriginalPos.x, draggedTileOriginalPos.y, draggedTileRotation, draggedTileFlipped, draggedTileShrineType, false, false, draggedTileId);
                } else if (isPlayerTile) {
                    // Player tile couldn't be placed - show why
                    updateStatus('‚ö†Ô∏è Player tiles must touch at least 2 unrevealed tiles!');
                }

                ghostTile.remove();
                ghostTile = null;
                isDraggingTile = false;
                draggedTileId = null;
                draggedTileOriginalPos = null;
                snapIndicator.classList.remove('active');
            } else if (isDraggingStone && ghostStone) {
                const rect = boardSvg.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                const world = screenToWorld(screenX, screenY);

                const stonePos = findValidStonePosition(world.x, world.y);
                if (stonePos.valid) {
                    placeStone(stonePos.x, stonePos.y, draggedStoneType);
                    if (draggedStoneId === null) {
                        console.log(`üì¶ Placing stone from deck: type=${draggedStoneType}, before=${stoneCounts[draggedStoneType]}`);
                        stoneCounts[draggedStoneType]--;
                        console.log(`üì¶ After decrement: ${draggedStoneType}=${stoneCounts[draggedStoneType]}, playerPool.${draggedStoneType}=${playerPool[draggedStoneType]}`);
                        updateStoneCount(draggedStoneType);

                        // Sync resources after placing stone
                        syncPlayerState();
                    }
                    updateStatus('Placed ' + draggedStoneType + ' stone');
                } else {
                    if (draggedStoneId !== null) {
                        // Was a placed stone, couldn't place back
                        returnStoneToPool(draggedStoneType);
                    }
                }

                ghostStone.remove();
                ghostStone = null;
                isDraggingStone = false;
                draggedStoneId = null;
                draggedStoneType = null;
                snapIndicator.classList.remove('active');
            } else if (isDraggingPlayer && ghostPlayer) {
                const rect = boardSvg.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                const world = screenToWorld(screenX, screenY);

                const playerPos = findNearestHexPosition(world.x, world.y);
                const totalCost = calculatePathCost();
                const startPos = playerPath[0];

                if (playerPos.valid && playerPath.length > 1) {
                    const finalPos = playerPath[playerPath.length - 1];
                    const moveCheck = canPlayerMoveToHex(finalPos.x, finalPos.y, true);

                    // Check if there's a stone at the final position that you CAN'T end turn on
                    const stoneAtFinal = placedStones.find(s => {
                        const dist = Math.sqrt(Math.pow(s.x - finalPos.x, 2) + Math.pow(s.y - finalPos.y, 2));
                        return dist < 5;
                    });

                    // Can't end turn on: earth, wind, water, fire
                    // CAN end turn on: void (or empty hex)
                    const cannotEndTurnHere = stoneAtFinal && stoneAtFinal.type !== 'void';

                    if (cannotEndTurnHere) {
                        console.log(`‚ùå Movement rejected: Cannot end turn on ${stoneAtFinal.type} stone at (${finalPos.x.toFixed(1)}, ${finalPos.y.toFixed(1)})`);
                        placePlayer(startPos.x, startPos.y);
                        updateStatus('Cannot end movement on a ' + stoneAtFinal.type + ' stone!');
                    } else if (moveCheck.canMove && totalCost <= getTotalAP()) {
                        console.log(`‚úÖ Movement successful: ${playerPath.length - 1} hexes, cost ${totalCost} AP`);
                        // Store the last move for undo
                        lastMove = {
                            prevPos: { x: startPos.x, y: startPos.y },
                            newPos: { x: finalPos.x, y: finalPos.y },
                            apCost: totalCost
                        };
                        placePlayer(finalPos.x, finalPos.y);
                        spendAP(totalCost); // Use void AP first, then regular AP

                        // Broadcast player movement to other players
                        broadcastGameAction('player-move', {
                            playerIndex: activePlayerIndex,
                            x: finalPos.x,
                            y: finalPos.y,
                            apSpent: totalCost
                        });

                        // Check if player stepped on a hidden tile - reveal it!
                        // Use the ACTUAL player position after placement
                        const actualPlayerPos = { x: playerPosition.x, y: playerPosition.y };
                        console.log(`üîç Player landed at (${actualPlayerPos.x.toFixed(1)}, ${actualPlayerPos.y.toFixed(1)})`);
                        console.log(`   finalPos from path: (${finalPos.x.toFixed(1)}, ${finalPos.y.toFixed(1)})`);

                        // Use getAllHexagonPositions which properly handles trapezoids
                        const allHexes = getAllHexagonPositions();
                        
                        // Find the hex position where the player landed
                        let playerHex = null;
                        let minDist = Infinity;
                        allHexes.forEach(hexPos => {
                            const dist = Math.sqrt(Math.pow(hexPos.x - actualPlayerPos.x, 2) + Math.pow(hexPos.y - actualPlayerPos.y, 2));
                            if (dist < minDist) {
                                minDist = dist;
                                playerHex = hexPos;
                            }
                        });

                        if (playerHex && minDist < 5 && playerHex.tiles) {
                            console.log(`   Player is on hex at (${playerHex.x.toFixed(1)}, ${playerHex.y.toFixed(1)}), dist=${minDist.toFixed(2)}`);
                            console.log(`   This hex is contributed to by ${playerHex.tiles.length} tile(s)`);
                            
                            // Find flipped tiles that contribute to this hex position
                            const flippedTiles = playerHex.tiles.filter(t => t.flipped && !t.isPlayerTile);
                            console.log(`   Flipped tiles at this hex:`, flippedTiles.map(t => ({id: t.id, x: t.x, y: t.y, flipped: t.flipped})));

                            if (flippedTiles.length > 0) {
                                // If multiple flipped tiles share this hex, choose the one whose center is closest to player
                                let tileToReveal = flippedTiles[0];
                                if (flippedTiles.length > 1) {
                                    let minTileDist = Infinity;
                                    flippedTiles.forEach(tile => {
                                        const tileDist = Math.sqrt(Math.pow(tile.x - actualPlayerPos.x, 2) + Math.pow(tile.y - actualPlayerPos.y, 2));
                                        console.log(`     Flipped tile id=${tile.id} at (${tile.x.toFixed(1)}, ${tile.y.toFixed(1)}): dist to center=${tileDist.toFixed(1)}`);
                                        if (tileDist < minTileDist) {
                                            minTileDist = tileDist;
                                            tileToReveal = tile;
                                        }
                                    });
                                    console.log(`   Multiple flipped tiles - choosing closest at (${tileToReveal.x.toFixed(1)}, ${tileToReveal.y.toFixed(1)})`);
                                }
                                console.log(`‚ú® Revealing tile id=${tileToReveal.id} at (${tileToReveal.x.toFixed(1)}, ${tileToReveal.y.toFixed(1)})`);
                                revealTile(tileToReveal.id);
                            } else {
                                console.log(`   No flipped tiles at this hex position`);
                                updateStatus(`Moved ${playerPath.length - 1} hexes (cost: ${totalCost} AP, ${getTotalAP()} AP remaining)`);
                            }
                        } else {
                            console.log(`   ‚ùå Player not on any valid hex (minDist=${minDist.toFixed(2)})`);
                            updateStatus(`Moved ${playerPath.length - 1} hexes (cost: ${totalCost} AP, ${getTotalAP()} AP remaining)`);
                        }
                    } else if (!moveCheck.canMove) {
                        console.log(`‚ùå Movement rejected: Path blocked at (${finalPos.x.toFixed(1)}, ${finalPos.y.toFixed(1)})`);
                        placePlayer(startPos.x, startPos.y);
                        updateStatus('Cannot move there!');
                    } else {
                        console.log(`‚ùå Movement rejected: Insufficient AP (need ${totalCost}, have ${getTotalAP()})`);
                        placePlayer(startPos.x, startPos.y);
                        updateStatus(`Not enough AP! (need ${totalCost}, have ${getTotalAP()})`);
                    }
                } else {
                    placePlayer(startPos.x, startPos.y);
                }

                ghostPlayer.remove();
                ghostPlayer = null;
                if (pathLine) {
                    pathLine.remove();
                    pathLine = null;
                }
                // Clean up path labels
                pathCostLabels.forEach(label => label.remove());
                pathCostLabels = [];
                playerPath = [];
                isDraggingPlayer = false;
                snapIndicator.classList.remove('active');
            }

            if (isPanning) {
                isPanning = false;
                boardSvg.style.cursor = 'grab';
            }
            if (isRotatingBoard) {
                isRotatingBoard = false;
                boardSvg.style.cursor = 'grab';
            }
            if (isRotatingTile) {
                isRotatingTile = false;
            }
        });

        // Clean up ghost when mouse leaves the board
        boardSvg.addEventListener('mouseleave', () => {
            snapIndicator.classList.remove('active');
        });

        // Touch event support for mobile
        
        // Touch handlers extracted for reuse (board + document)
        function handleBoardTouchStart(e) {
            touchStartTime = Date.now();
            const coords = getEventCoords(e);
            touchStartPos = { x: coords.x, y: coords.y };
            // Single-finger pan (only when not interacting with a tile/player/stone)
            if (e.touches.length === 1 && !isDraggingTile && !isDraggingStone && !isDraggingPlayer) {
                const targetClass = e.target?.getAttribute && e.target.getAttribute('class');
                const isStone = targetClass && (targetClass.includes('stone') || e.target.closest('.stone'));
                const isPlayer = targetClass && (targetClass.includes('player') || e.target.closest('.player'));
                const isTile = e.target && (e.target.closest('.placed-tile') || e.target.closest('.tile'));
                if (!isStone && !isPlayer && !isTile) {
                    e.preventDefault();
                    isPanning = true;
                    panStartX = coords.x;
                    panStartY = coords.y;
                    lastPanX = viewportX;
                    lastPanY = viewportY;
                    boardSvg.style.cursor = 'grabbing';
                }
            }


            if (e.touches.length === 2 && !isDraggingTile && !isDraggingPlayer) {
                // Two-finger pinch zoom / pan (board)
                e.preventDefault();
                isPinching = true;
                isGestureRotating = false;

                const dx = e.touches[1].clientX - e.touches[0].clientX;
                const dy = e.touches[1].clientY - e.touches[0].clientY;
                pinchStartDist = Math.hypot(dx, dy) || 1;
                pinchStartScale = viewportScale;

                const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                pinchStartMid = { x: midX, y: midY };
                pinchLastMid = { x: midX, y: midY };
            }
        
        }

        function handleBoardTouchMove(e) {
            e.preventDefault(); // Prevent scrolling

            if (e.touches.length === 2 && isPinching) {
                // Pinch zoom / pan board
                const dx = e.touches[1].clientX - e.touches[0].clientX;
                const dy = e.touches[1].clientY - e.touches[0].clientY;
                const dist = Math.hypot(dx, dy) || 1;

                // Midpoint pan
                const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                const midDeltaX = midX - pinchLastMid.x;
                const midDeltaY = midY - pinchLastMid.y;
                pinchLastMid = { x: midX, y: midY };

                // Apply pan in world space
                viewportX += midDeltaX / viewportScale;
                viewportY += midDeltaY / viewportScale;

                // Apply zoom anchored near screen midpoint (approx)
                let newScale = pinchStartScale * (dist / pinchStartDist);
                newScale = Math.max(0.25, Math.min(3.0, newScale));

                const centerX = boardSvg.width.baseVal.value / 2;
                const centerY = boardSvg.height.baseVal.value / 2;

                // Keep pinch midpoint roughly stable during zoom
                const k = (1 / viewportScale) - (1 / newScale);
                viewportX += (midX - centerX) * k;
                viewportY += (midY - centerY) * k;

                viewportScale = newScale;
                updateViewport();
                return;
            }

            else if (e.touches.length === 1) {
                // Single touch - pan or drag
                if (isPanning && !isDraggingTile && !isDraggingStone && !isDraggingPlayer) {
                    const dx = e.touches[0].clientX - panStartX;
                    const dy = e.touches[0].clientY - panStartY;
                    const rad = -viewportRotation * Math.PI / 180;
                    const cos = Math.cos(rad);
                    const sin = Math.sin(rad);
                    const rotatedDx = dx * cos - dy * sin;
                    const rotatedDy = dx * sin + dy * cos;
                    viewportX = lastPanX + rotatedDx;
                    viewportY = lastPanY + rotatedDy;
                    updateViewport();
                    return;
                }
                // Single touch - handle drag
                const rect = boardSvg.getBoundingClientRect();
                const screenX = e.touches[0].clientX - rect.left;
                const screenY = e.touches[0].clientY - rect.top;
                const world = screenToWorld(screenX, screenY);

                if (isDraggingTile && ghostTile) {
                    const isPlayerTile = (draggedTileShrineType === 'player');
                    const snapResult = findNearestSnapPoint(world.x, world.y, isPlayerTile);
                    ghostTile.setAttribute('transform', `translate(${snapResult.x}, ${snapResult.y})`);

                    if (snapResult.snapped) {
                        snapIndicator.setAttribute('cx', snapResult.x);
                        snapIndicator.setAttribute('cy', snapResult.y);
                        snapIndicator.classList.add('active');
                    } else {
                        snapIndicator.classList.remove('active');
                    }
                } else if (isDraggingStone && ghostStone) {
                    const stonePos = findValidStonePosition(world.x, world.y);
                    ghostStone.setAttribute('transform', `translate(${stonePos.x}, ${stonePos.y})`);

                    if (stonePos.valid) {
                        snapIndicator.setAttribute('cx', stonePos.x);
                        snapIndicator.setAttribute('cy', stonePos.y);
                        snapIndicator.classList.add('active');
                    } else {
                        snapIndicator.classList.remove('active');
                    }
                } else if (isDraggingPlayer && ghostPlayer) {
                    const playerPos = findNearestHexPosition(world.x, world.y);
                    ghostPlayer.setAttribute('transform', `translate(${playerPos.x}, ${playerPos.y})`);

                    if (playerPos.valid) {
                        updatePlayerPath(playerPos.x, playerPos.y);

                        const totalCost = calculatePathCost();
                        const moveCheck = canPlayerMoveToHex(playerPos.x, playerPos.y);

                        if (moveCheck.canMove && totalCost <= getTotalAP()) {
                            snapIndicator.setAttribute('cx', playerPos.x);
                            snapIndicator.setAttribute('cy', playerPos.y);
                            snapIndicator.classList.add('active');
                        } else {
                            snapIndicator.classList.remove('active');
                        }

                        updateStatus(`Path cost: ${totalCost} AP (${getTotalAP() - totalCost} remaining)`);
                    } else {
                        snapIndicator.classList.remove('active');
                    }
                }
            }
        
        }

        function handleBoardTouchEnd(e) {
            const touchDuration = Date.now() - touchStartTime;
            const coords = e.changedTouches[0];
            const rect = boardSvg.getBoundingClientRect();
            const screenX = coords.clientX - rect.left;
            const screenY = coords.clientY - rect.top;

            // Check if this was a tap (short touch without much movement)
            const distMoved = Math.sqrt(
                Math.pow(coords.clientX - touchStartPos.x, 2) +
                Math.pow(coords.clientY - touchStartPos.y, 2)
            );
            const isTap = touchDuration < 300 && distMoved < 10;

            if (isPanning) {
                isPanning = false;
                boardSvg.style.cursor = 'grab';
            }

            if (isTap && isDraggingTile && ghostTile) {
                // Tap to flip
                draggedTileFlipped = !draggedTileFlipped;

                // Regenerate ghost tile with new flip state
                const oldTransform = ghostTile.getAttribute('transform');
                const translateMatch = oldTransform?.match(/translate\(([^,]+),\s*([^)]+)\)/);
                const currentX = translateMatch ? parseFloat(translateMatch[1]) : 0;
                const currentY = translateMatch ? parseFloat(translateMatch[2]) : 0;

                viewport.removeChild(ghostTile);
                ghostTile = createTileGroup(draggedTileRotation, draggedTileFlipped, draggedTileShrineType);
                ghostTile.classList.add('ghost-tile');
                ghostTile.setAttribute('transform', `translate(${currentX}, ${currentY})`);
                viewport.appendChild(ghostTile);
            } else {
                // Handle drop (same logic as mouseup)
                const world = screenToWorld(screenX, screenY);

                if (isDraggingTile && ghostTile) {
                    const isPlayerTile = (draggedTileShrineType === 'player');
                    const snapResult = findNearestSnapPoint(world.x, world.y, isPlayerTile);
                    if (snapResult.snapped) {
                        console.log(`Placing tile: rotation=${draggedTileRotation}, flipped=${draggedTileFlipped}, shrine=${draggedTileShrineType}`);
                        const tileId = placeTile(snapResult.x, snapResult.y, draggedTileRotation, draggedTileFlipped, draggedTileShrineType, false, false, draggedTileId);

                        if (draggedTileShrineType === 'player' && draggedTileId === null && tileId !== null) {
                            playerTilesAvailable--;
                            document.getElementById('player-tile-count').textContent = playerTilesAvailable;
                            if (isMobile) document.getElementById('mobile-tile-count').textContent = playerTilesAvailable;

                            if (playerTileElements.length > 0) {
                                const tileToRemove = playerTileElements.shift();
                                tileToRemove.remove();
                            }

                            if (isMultiplayer) {
                                // Broadcast for other clients to place the player tile visually.
                                broadcastGameAction('player-tile-place', {
                                    x: snapResult.x,
                                    y: snapResult.y,
                                    playerIndex: myPlayerIndex,
                                    color: playerColor
                                });
                            }
                        } else if (draggedTileId !== null) {
                            // Moving already-placed non-player tiles is not synced in multiplayer; revert to avoid desync.
                            if (isMultiplayer && draggedTileOriginalPos) {
                                updateStatus('‚ö†Ô∏è Tiles cannot be moved in multiplayer.');
                                placeTile(draggedTileOriginalPos.x, draggedTileOriginalPos.y, draggedTileRotation, draggedTileFlipped, draggedTileShrineType, false, false, draggedTileId);
                            }
                        }
                    } else if (draggedTileOriginalPos && draggedTileId !== null) {
                        placeTile(draggedTileOriginalPos.x, draggedTileOriginalPos.y, draggedTileRotation, draggedTileFlipped, draggedTileShrineType, false, false, draggedTileId);
                    } else if (draggedTileShrineType === 'player') {
                        updateStatus('Player tiles must touch 2+ adjacent unrevealed tiles');
                    }

                    viewport.removeChild(ghostTile);
                    ghostTile = null;
                    isDraggingTile = false;
                    draggedTileId = null;
                    draggedTileOriginalPos = null;
                    snapIndicator.classList.remove('active');
                } else if (isDraggingStone && ghostStone) {
                    const stonePos = findValidStonePosition(world.x, world.y);
                    if (stonePos.valid) {
                        const stoneId = placeStone(stonePos.x, stonePos.y, draggedStoneType);

                        if (draggedStoneId === null) {
                            playerPool[draggedStoneType]--;
                            updateStoneCountDisplay(draggedStoneType);
                            syncPlayerState();
                        }

                        if (isMultiplayer && stoneId) {
                            broadcastStonePlace(stoneId, stonePos.x, stonePos.y, draggedStoneType);
                        }
                    } else if (draggedStoneId !== null) {
                        playerPool[draggedStoneType]++;
                        updateStoneCountDisplay(draggedStoneType);
                        syncPlayerState();
                    }

                    viewport.removeChild(ghostStone);
                    ghostStone = null;
                    isDraggingStone = false;
                    draggedStoneId = null;
                    snapIndicator.classList.remove('active');
                } else if (isDraggingPlayer && ghostPlayer) {
                    const playerPos = findNearestHexPosition(world.x, world.y);
                    const startPos = playerPath[0];
                    let movementSuccessful = false;

                    if (playerPath.length > 1 && playerPos.valid) {
                        const totalCost = calculatePathCost();
                        const finalPos = playerPath[playerPath.length - 1];
                        const moveCheck = canPlayerMoveToHex(finalPos.x, finalPos.y, true);

                        // Check if there's a stone at the final position that you CAN'T end turn on
                        const stoneAtFinal = placedStones.find(s => {
                            const dist = Math.sqrt(Math.pow(s.x - finalPos.x, 2) + Math.pow(s.y - finalPos.y, 2));
                            return dist < 5;
                        });
                        const cannotEndTurnHere = stoneAtFinal && stoneAtFinal.type !== 'void';

                        if (cannotEndTurnHere) {
                            updateStatus('Cannot end movement on a ' + stoneAtFinal.type + ' stone!');
                        } else if (!moveCheck.canMove) {
                            updateStatus(moveCheck.reason || 'Cannot move to this position');
                        } else if (totalCost > getTotalAP()) {
                            updateStatus(`Not enough AP (need ${totalCost}, have ${getTotalAP()})`);
                        } else {
                            // Store the last move for undo
                            lastMove = {
                                prevPos: { x: startPos.x, y: startPos.y },
                                newPos: { x: finalPos.x, y: finalPos.y },
                                apCost: totalCost
                            };
                            placePlayer(finalPos.x, finalPos.y);
                            spendAP(totalCost);
                            movementSuccessful = true;

                            // Broadcast player movement to other players
                            if (isMultiplayer) {
                                broadcastGameAction('player-move', {
                                    playerIndex: activePlayerIndex,
                                    x: finalPos.x,
                                    y: finalPos.y,
                                    apSpent: totalCost
                                });
                            }

                            // Check if player stepped on a hidden tile - reveal it!
                            const actualPlayerPos = { x: playerPosition.x, y: playerPosition.y };
                            const allHexes = getAllHexagonPositions();

                            let playerHex = null;
                            let minDist = Infinity;
                            allHexes.forEach(hexPos => {
                                const dist = Math.sqrt(Math.pow(hexPos.x - actualPlayerPos.x, 2) + Math.pow(hexPos.y - actualPlayerPos.y, 2));
                                if (dist < minDist) {
                                    minDist = dist;
                                    playerHex = hexPos;
                                }
                            });

                            if (playerHex && minDist < 5 && playerHex.tiles) {
                                const flippedTiles = playerHex.tiles.filter(t => t.flipped && !t.isPlayerTile);
                                flippedTiles.forEach(tileInfo => {
                                    revealTile(tileInfo.id);
                                });
                            }
                        }
                    }

                    // If movement failed or was cancelled, restore player to start position
                    if (!movementSuccessful && startPos) {
                        placePlayer(startPos.x, startPos.y);
                    }

                    if (ghostPlayer) {
                        viewport.removeChild(ghostPlayer);
                        ghostPlayer = null;
                    }
                    clearPlayerPath();
                    isDraggingPlayer = false;
                    snapIndicator.classList.remove('active');
                }
            }

            isGestureRotating = false;
            isPinching = false;
            initialTouches = [];
        
        }

boardSvg.addEventListener('touchstart', handleBoardTouchStart, { passive: false });

        boardSvg.addEventListener('touchmove', handleBoardTouchMove, { passive: false });

        boardSvg.addEventListener('touchend', handleBoardTouchEnd, { passive: false });
        // Ensure deck-origin drags keep updating even when touch target isn't the board SVG
        document.addEventListener('touchmove', (e) => {
            if (isDraggingTile || isDraggingPlayer || isDraggingStone || isPanning || isPinching) {
                handleBoardTouchMove(e);
            }
        }, { passive: false });

        document.addEventListener('touchend', (e) => {
            if (isDraggingTile || isDraggingPlayer || isDraggingStone || isPanning || isPinching) {
                handleBoardTouchEnd(e);
            }
        }, { passive: false });

        document.addEventListener('touchcancel', (e) => {
            if (isDraggingTile || isDraggingPlayer || isDraggingStone || isPanning || isPinching) {
                handleBoardTouchEnd(e);
            }
        }, { passive: false });


        boardSvg.addEventListener('mousedown', (e) => {
            console.log(`üñ±Ô∏è boardSvg mousedown: button=${e.button}, shift=${e.shiftKey}, target=${e.target.tagName}`);
            
            if (e.button === 0) leftButtonDown = true;
            if (e.button === 2) rightButtonDown = true;

            // SHIFT+CLICK: Debug mode - pin hex coordinates
            if (e.shiftKey && e.button === 0) {
                console.log(`üîç SHIFT+CLICK DETECTED!`);
                e.preventDefault();
                e.stopPropagation();
                const rect = boardSvg.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                const world = screenToWorld(screenX, screenY);
                
                console.log(`üìç DEBUG: Shift+Click at screen (${screenX.toFixed(1)}, ${screenY.toFixed(1)})`);
                console.log(`   World coordinates: (${world.x.toFixed(1)}, ${world.y.toFixed(1)})`);
                
                // Find nearest hex position
                const hexPos = findNearestHexPosition(world.x, world.y);
                if (hexPos.valid) {
                    console.log(`   Nearest hex: (${hexPos.x.toFixed(1)}, ${hexPos.y.toFixed(1)})`);
                    
                    // Find all hexagon positions to see which tiles contribute
                    const allHexes = getAllHexagonPositions();
                    const matchingHex = allHexes.find(h => {
                        const dist = Math.sqrt(Math.pow(h.x - hexPos.x, 2) + Math.pow(h.y - hexPos.y, 2));
                        return dist < 5;
                    });
                    
                    if (matchingHex && matchingHex.tiles) {
                        console.log(`   This hex is contributed by ${matchingHex.tiles.length} tile(s):`);
                        matchingHex.tiles.forEach((tile, i) => {
                            console.log(`     [${i}] Tile at (${tile.x.toFixed(1)}, ${tile.y.toFixed(1)}): flipped=${tile.flipped}, shrine=${tile.shrineType}, id=${tile.id}`);
                        });
                    }
                }
                
                // Create visual debug marker
                const marker = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                marker.setAttribute('class', 'debug-marker');
                marker.setAttribute('transform', `translate(${world.x}, ${world.y})`);
                
                // Draw crosshair
                const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line1.setAttribute('x1', '-10');
                line1.setAttribute('y1', '0');
                line1.setAttribute('x2', '10');
                line1.setAttribute('y2', '0');
                line1.setAttribute('stroke', '#ff00ff');
                line1.setAttribute('stroke-width', '2');
                marker.appendChild(line1);
                
                const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line2.setAttribute('x1', '0');
                line2.setAttribute('y1', '-10');
                line2.setAttribute('x2', '0');
                line2.setAttribute('y2', '10');
                line2.setAttribute('stroke', '#ff00ff');
                line2.setAttribute('stroke-width', '2');
                marker.appendChild(line2);
                
                // Draw circle
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', '0');
                circle.setAttribute('cy', '0');
                circle.setAttribute('r', '5');
                circle.setAttribute('fill', 'none');
                circle.setAttribute('stroke', '#ff00ff');
                circle.setAttribute('stroke-width', '2');
                marker.appendChild(circle);
                
                // Add text label
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', '12');
                text.setAttribute('y', '5');
                text.setAttribute('fill', '#ff00ff');
                text.setAttribute('font-size', '10');
                text.setAttribute('font-weight', 'bold');
                text.textContent = `(${world.x.toFixed(0)}, ${world.y.toFixed(0)})`;
                marker.appendChild(text);
                
                viewport.appendChild(marker);
                debugMarkers.push(marker);
                
                updateStatus(`DEBUG: Pinned (${world.x.toFixed(1)}, ${world.y.toFixed(1)}) - Check console for details`);
                return; // Don't start panning
            }

            // Don't start panning if we're already dragging something
            if (isDraggingTile || isDraggingStone || isDraggingPlayer) return;

            const targetClass = e.target.getAttribute('class');
            const isStone = targetClass && (targetClass.includes('stone') || e.target.closest('.stone'));
            const isPlayer = targetClass && (targetClass.includes('player') || e.target.closest('.player'));

            if (e.button === 0 && (e.target === boardSvg || e.target === viewport || e.target.tagName === 'polygon') && !isStone && !isPlayer) {
                e.preventDefault();
                isPanning = true;
                panStartX = e.clientX;
                panStartY = e.clientY;
                lastPanX = viewportX;
                lastPanY = viewportY;
                boardSvg.style.cursor = 'grabbing';
            } else if (e.button === 2 && (e.target === boardSvg || e.target === viewport)) {
                e.preventDefault();
                isRotatingBoard = true;
                rotateStartX = e.clientX;
                rotateStartRotation = viewportRotation;
                boardSvg.style.cursor = 'grabbing';
            }
        });

        boardSvg.addEventListener('contextmenu', (e) => e.preventDefault());

        document.addEventListener('mousemove', (e) => {
            if (isPanning) {
                const dx = e.clientX - panStartX;
                const dy = e.clientY - panStartY;
                const rad = -viewportRotation * Math.PI / 180;
                const cos = Math.cos(rad);
                const sin = Math.sin(rad);
                const rotatedDx = dx * cos - dy * sin;
                const rotatedDy = dx * sin + dy * cos;
                viewportX = lastPanX + rotatedDx;
                viewportY = lastPanY + rotatedDy;
                updateViewport();
            } else if (isRotatingBoard) {
                const dx = e.clientX - rotateStartX;
                viewportRotation = rotateStartRotation + (dx / 100) * 90;
                updateViewport();
            } else if (isRotatingTile) {
                const dx = e.clientX - rotateTileStartX;
                const steps = Math.round(dx / 60);
                currentRotation = (rotateTileStartRotation - steps + 6) % 6; // Reversed direction: subtract instead of add
                drawDeckTile();
            }
        });

        // Debug mode: array to store debug markers
        let debugMarkers = [];

        document.addEventListener('keydown', (e) => {
            console.log(`Key pressed: ${e.key}, isDraggingTile=${isDraggingTile}, ghostTile=${!!ghostTile}, shift=${e.shiftKey}`);
            if (e.key === 'f' || e.key === 'F') {
                console.log(`F key detected! isDraggingTile=${isDraggingTile}, ghostTile exists=${!!ghostTile}, shift=${e.shiftKey}`);
                
                // SHIFT+F: Debug mode - show tile coordinates
                if (e.shiftKey && isDraggingTile && ghostTile) {
                    console.log(`üîç DEBUG: Tile being dragged`);
                    console.log(`   draggedTileId: ${draggedTileId}`);
                    console.log(`   draggedTileShrineType: ${draggedTileShrineType}`);
                    console.log(`   draggedTileFlipped: ${draggedTileFlipped}`);
                    console.log(`   draggedTileRotation: ${draggedTileRotation}`);
                    if (draggedTileOriginalPos) {
                        console.log(`   Original position: (${draggedTileOriginalPos.x.toFixed(1)}, ${draggedTileOriginalPos.y.toFixed(1)})`);
                    }
                    
                    // Get current ghost position
                    const transform = ghostTile.getAttribute('transform');
                    console.log(`   Current ghost transform: ${transform}`);
                    
                    updateStatus(`DEBUG: Tile ID=${draggedTileId}, shrine=${draggedTileShrineType}, flipped=${draggedTileFlipped}`);
                }
                // Normal F: Flip the tile
                else if (!e.shiftKey && isDraggingTile && ghostTile) {
                    console.log(`Before flip: draggedTileFlipped=${draggedTileFlipped}`);
                    // Flip the tile being dragged
                    draggedTileFlipped = !draggedTileFlipped;
                    console.log(`After flip: draggedTileFlipped=${draggedTileFlipped}`);

                    // Update the ghost tile visual
                    ghostTile.innerHTML = '';
                    const tile = createTileGroup(TILE_SIZE, draggedTileRotation, draggedTileFlipped);
                    ghostTile.appendChild(tile);

                    updateStatus(`Tile ${draggedTileFlipped ? 'flipped' : 'unflipped'}`);
                    console.log(`Tile visual updated`);
                } else {
                    console.log(`Cannot flip - not dragging a tile or no ghost tile`);
                }
            }
        });

        boardSvg.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = boardSvg.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const worldBefore = screenToWorld(mouseX, mouseY);
            const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
            viewportScale = Math.max(0.1, Math.min(10, viewportScale * zoomFactor));
            const worldAfter = screenToWorld(mouseX, mouseY);
            viewportX += (worldAfter.x - worldBefore.x) * viewportScale;
            viewportY += (worldAfter.y - worldBefore.y) * viewportScale;
            updateViewport();
        });

        document.getElementById('end-turn').onclick = function() {
            // In multiplayer, only allow ending turn if it's your turn
            if (!isMyTurn()) {
                notYourTurn();
                return;
            }

            // Check if current player is on a shrine
            if (playerPosition) {
                const shrine = findShrineAtPosition(playerPosition.x, playerPosition.y);
                if (shrine && shrine.shrineType !== 'catacomb') {
                    // Regular shrine - replenish stones (catacomb doesn't replenish)
                    replenishShrineStones(shrine.shrineType);
                }
            }

            currentAP = 5;
            document.getElementById('ap-count').textContent = currentAP;
            updateVoidAP(); // Update void AP to match current void stones
            lastMove = null; // Clear undo history on new turn

            // Sync AP restoration in multiplayer
            syncPlayerState();

            // Switch to next player based on color rank
            if (playerPositions.length > 1) {
                // Color rank order: void(1) -> wind(2) -> fire(3) -> water(4) -> earth(5)
                const COLOR_RANK = {
                    '#9458f4': 1, // purple/void
                    '#ffce00': 2, // yellow/wind
                    '#ed1b43': 3, // red/fire
                    '#5894f4': 4, // blue/water
                    '#69d83a': 5  // green/earth
                };

                // Sort players by rank
                const sortedPlayers = [...playerPositions].map((p, idx) => ({
                    index: idx,
                    rank: COLOR_RANK[p.color] || 999
                })).sort((a, b) => a.rank - b.rank);

                // Find current player in sorted list
                const currentSortedIndex = sortedPlayers.findIndex(p => p.index === activePlayerIndex);
                
                // Move to next player in sorted order (wrap around)
                const nextSortedIndex = (currentSortedIndex + 1) % sortedPlayers.length;
                activePlayerIndex = sortedPlayers[nextSortedIndex].index;

                const colorNames = {
                    '#9458f4': 'Purple (Void)',
                    '#ffce00': 'Yellow (Wind)',
                    '#ed1b43': 'Red (Fire)',
                    '#5894f4': 'Blue (Water)',
                    '#69d83a': 'Green (Earth)'
                };

                const nextPlayer = playerPositions[activePlayerIndex];
                const nextPlayerColorName = getPlayerColorName(activePlayerIndex);

                // Update UI to show new player's inventory
                Object.keys(stoneCounts).forEach(updateStoneCount);
                spellSystem.updateScrollCount();

                updateStatus(`Turn ended. Now ${nextPlayerColorName}'s turn! AP restored.`);
                console.log(`üîÑ Switched to player ${activePlayerIndex + 1} (${nextPlayerColorName})`);

                // Broadcast turn change in multiplayer
                if (isMultiplayer) {
                    const startedAt = Date.now();
                    turnStartedAtMs = startedAt;
                    broadcastGameAction('turn-change', {
                        playerIndex: activePlayerIndex,
                        turnStartedAt: startedAt
                    });
                }
            } else {
                updateStatus('Turn ended. AP restored.');
            }
        };

        
        // Inventory toggle button
        const invBtn = document.getElementById('inventory-toggle');
        if (invBtn) invBtn.onclick = toggleInventory;
document.getElementById('undo-move').onclick = function() {
            if (!lastMove) {
                updateStatus('No move to undo!');
                return;
            }

            // Restore previous position
            placePlayer(lastMove.prevPos.x, lastMove.prevPos.y);

            // Restore AP
            currentAP += lastMove.apCost;
            document.getElementById('ap-count').textContent = currentAP;

            updateStatus(`Undid movement. Restored ${lastMove.apCost} AP (now ${currentAP} AP).`);

            // Broadcast undo in multiplayer
            if (isMultiplayer) {
                broadcastGameAction('undo-move', {
                    playerIndex: activePlayerIndex,
                    x: lastMove.prevPos.x,
                    y: lastMove.prevPos.y,
                    apRestored: lastMove.apCost
                });
            }

            // Clear the undo history (can only undo once)
            lastMove = null;
        };

        document.getElementById('scroll-inventory').onclick = function() {
            spellSystem.showInventory();
        };

        document.getElementById('cast-spell').onclick = function() {
            spellSystem.castSpell();
        };

        document.getElementById('leave-game').onclick = function() {
            leaveGame();
        };

        function findShrineAtPosition(x, y) {
            // Check each tile to see if player is on the center hex (shrine location)
            for (const tile of placedTiles) {
                const dist = Math.sqrt(Math.pow(tile.x - x, 2) + Math.pow(tile.y - y, 2));
                // Center hex is at the tile's position (0,0 offset)
                if (dist < 5) {
                    return tile;
                }
            }
            return null;
        }

        function replenishShrineStones(shrineType) {
            // Stone rank determines replenishment amount
            const STONE_RANK = {
                'void': 1,
                'wind': 2,
                'fire': 3,
                'water': 4,
                'earth': 5
            };

            const replenishAmount = STONE_RANK[shrineType];

            // Calculate how many stones we can actually transfer
            // Limited by: source pool availability, player pool capacity, and replenish amount
            const availableInSource = sourcePool[shrineType];
            const spaceInPlayer = playerPoolCapacity[shrineType] - playerPool[shrineType];
            const actualReplenished = Math.min(replenishAmount, availableInSource, spaceInPlayer);

            if (actualReplenished > 0) {
                // Transfer from source pool to player pool
                sourcePool[shrineType] -= actualReplenished;
                playerPool[shrineType] += actualReplenished;
                updateStoneCount(shrineType);

                // Sync resources in multiplayer
                syncPlayerState();

                updateStatus(`Shrine activated! Transferred ${actualReplenished} ${shrineType} stone${actualReplenished > 1 ? 's' : ''} from source to player pool. (Source: ${sourcePool[shrineType]}/${sourcePoolCapacity[shrineType]}, Player: ${playerPool[shrineType]}/${playerPoolCapacity[shrineType]}). AP restored.`);
            } else if (spaceInPlayer === 0) {
                updateStatus(`Shrine activated but player pool is full! (${playerPool[shrineType]}/${playerPoolCapacity[shrineType]}). AP restored.`);
            } else if (availableInSource === 0) {
                updateStatus(`Shrine activated but source pool is empty! (${sourcePool[shrineType]}/${sourcePoolCapacity[shrineType]}). AP restored.`);
            }
        }

        let activeTeleportIndicators = [];

        function updateCatacombIndicators() {
            // Remove existing indicators
            activeTeleportIndicators.forEach(ind => ind.remove());
            activeTeleportIndicators = [];

            // Check if player is on a catacomb shrine
            if (!playerPosition) return;

            const currentShrine = findShrineAtPosition(playerPosition.x, playerPosition.y);
            if (!currentShrine || currentShrine.shrineType !== 'catacomb') return;

            // Find all other REVEALED catacomb shrines (not flipped) WITHOUT stones on them
            const otherCatacombs = placedTiles.filter(tile => {
                if (tile.shrineType !== 'catacomb') return false;
                if (tile.flipped) return false; // Only revealed catacombs
                if (Math.abs(tile.x - currentShrine.x) <= 5 && Math.abs(tile.y - currentShrine.y) <= 5) return false; // Same catacomb
                
                // Check if there's a stone at the catacomb center
                const hasStone = placedStones.some(stone => {
                    const dist = Math.sqrt(Math.pow(stone.x - tile.x, 2) + Math.pow(stone.y - tile.y, 2));
                    return dist < 5; // Stone is at the center of this catacomb
                });
                
                return !hasStone; // Only allow teleport to catacombs without stones
            });

            if (otherCatacombs.length === 0) {
                updateStatus('‚ö∞ Standing on catacomb shrine, but no valid destinations! (catacombs must be revealed and have no stone on center)');
                return;
            }

            // Create visual indicators for teleport destinations
            otherCatacombs.forEach(shrine => {
                const indicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                indicator.setAttribute('cx', shrine.x);
                indicator.setAttribute('cy', shrine.y);
                indicator.setAttribute('r', '15');
                indicator.setAttribute('fill', '#8b4513');
                indicator.setAttribute('opacity', '0.5');
                indicator.setAttribute('stroke', '#fff');
                indicator.setAttribute('stroke-width', '2');
                indicator.setAttribute('class', 'teleport-indicator');
                indicator.style.cursor = 'pointer';
                indicator.style.animation = 'pulse 1s infinite';

                // Add click handler for teleportation
                indicator.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();

                    // Double-check no stone was placed since indicators were created
                    const hasStoneNow = placedStones.some(stone => {
                        const dist = Math.sqrt(Math.pow(stone.x - shrine.x, 2) + Math.pow(stone.y - shrine.y, 2));
                        return dist < 5;
                    });
                    
                    if (hasStoneNow) {
                        updateStatus('‚ö∞ Cannot teleport there - a stone is blocking the catacomb!');
                        updateCatacombIndicators(); // Refresh indicators
                        return;
                    }

                    // Teleport player (no AP cost)
                    placePlayer(shrine.x, shrine.y);
                    updateStatus(`‚ö∞ Teleported to another catacomb shrine!`);

                    // Update indicators for new position
                    updateCatacombIndicators();
                });

                viewport.appendChild(indicator);
                activeTeleportIndicators.push(indicator);
            });

            updateStatus(`‚ö∞ Standing on catacomb shrine. Click on another revealed catacomb (glowing circles) to teleport there (free).`);
        }

        // Generate spiral tile positions starting from center
        // Based on the spiral pattern from the image: 1(center), 2(SE), 3(SW), 4(W), 5(NW), 6(NE), 7(E), then ring 2...
        function generateSpiralPositions(numTiles) {
            const positions = [];
            const largeHexSize = TILE_SIZE * 4; // Grid size for tile snapping

            // Predefined spiral path in axial coordinates (q, r)
            // 6 tiles per player (one of each shrine type)
            const spiralPath = [
                { q: 0, r: 0 },    // 1 - Center
                { q: 0, r: 1 },    // 2 - SE
                { q: -1, r: 1 },   // 3 - SW
                { q: -1, r: 0 },   // 4 - W
                { q: 0, r: -1 },   // 5 - NW
                { q: 1, r: -1 },   // 6 - NE (1 player complete - 6 tiles)
                { q: 1, r: 0 },    // 7 - E
                { q: 1, r: 1 },    // 8 - SE (ring 2)
                { q: 0, r: 2 },    // 9
                { q: -1, r: 2 },   // 10
                { q: -2, r: 2 },   // 11
                { q: -2, r: 1 },   // 12 (2 players complete - 12 tiles)
                { q: -2, r: 0 },   // 13
                { q: -1, r: -1 },  // 14
                { q: 0, r: -2 },   // 15
                { q: 1, r: -2 },   // 16
                { q: 2, r: -2 },   // 17
                { q: 2, r: -1 },   // 18 (3 players complete - 18 tiles)
                { q: 2, r: 0 },    // 19
                { q: 2, r: 1 },    // 20
                { q: 1, r: 2 },    // 21 (ring 3)
                { q: 0, r: 3 },    // 22
                { q: -1, r: 3 },   // 23
                { q: -2, r: 3 },   // 24 (4 players complete - 24 tiles)
                { q: -3, r: 3 },   // 25
                { q: -3, r: 2 },   // 26
                { q: -3, r: 1 },   // 27
                { q: -3, r: 0 },   // 28
                { q: -2, r: -1 },  // 29
                { q: -1, r: -2 },  // 30 (5 players complete - 30 tiles)
                { q: 0, r: -3 },   // 31 (extra positions for future)
                { q: 1, r: -3 },   // 32
                { q: 2, r: -3 },   // 33
                { q: 3, r: -3 },   // 34
                { q: 3, r: -2 },   // 35
                { q: 3, r: -1 },   // 36
            ];

            // Convert to pixel positions
            for (let i = 0; i < Math.min(numTiles, spiralPath.length); i++) {
                const pos = hexToPixel(spiralPath[i].q, spiralPath[i].r, largeHexSize);
                positions.push({ x: pos.x, y: pos.y });
            }

            return positions;
        }


        // ========================================
        // MULTIPLAYER LOBBY FUNCTIONS
        // ========================================

        let isHost = false; // Track if this player is the host

        let isJoining = false; // Prevent double-joins

        // Join the lobby
        async function joinLobby() {
            // Prevent double-joins
            if (isJoining) {
                console.log('Already joining, please wait...');
                return;
            }

            const usernameInput = document.getElementById('username-input');
            const username = usernameInput.value.trim();

            if (!username) {
                alert('Please enter a username!');
                return;
            }

            // Disable input and button, show loading spinner
            isJoining = true;
            const joinButton = document.getElementById('join-button');
            const loadingDiv = document.getElementById('join-loading');
            joinButton.disabled = true;
            usernameInput.disabled = true;
            loadingDiv.style.display = 'block';

            try {
                // First, clean up any stale players (older than 10 minutes)
                // Increased timeout for development - players won't be kicked while debugging
                await supabase
                    .from('players')
                    .delete()
                    .lt('last_seen', new Date(Date.now() - 600000).toISOString());

                // Also reset game room to waiting if it was stuck in playing or finished
                const { data: room } = await supabase
                    .from('game_room')
                    .select('status')
                    .eq('id', 1)
                    .single();

                if (room && (room.status === 'playing' || room.status === 'finished')) {
                    await supabase
                        .from('game_room')
                        .update({ status: 'waiting', current_turn_index: 0 })
                        .eq('id', 1);
                }

                // Check if username is already taken
                const { data: existingPlayers } = await supabase
                    .from('players')
                    .select('*')
                    .order('created_at', { ascending: true });

                const usernameTaken = existingPlayers && existingPlayers.some(p => p.username === username);
                if (usernameTaken) {
                    alert('Username already taken! Please choose a different name.');
                    // Re-enable inputs
                    isJoining = false;
                    joinButton.disabled = false;
                    usernameInput.disabled = false;
                    loadingDiv.style.display = 'none';
                    return;
                }

                // Insert player into database
                const { data, error } = await supabase
                    .from('players')
                    .insert([{ username, is_ready: false }])
                    .select()
                    .single();

                if (error) throw error;

                myPlayerId = data.id;
                isMultiplayer = true;

                // After insertion, check if we're the first player (host)
                // The host is simply the player with the oldest created_at timestamp
                const { data: allPlayersAfterInsert } = await supabase
                    .from('players')
                    .select('*')
                    .order('created_at', { ascending: true });

                // We're host if we're the first player (by creation time)
                isHost = allPlayersAfterInsert && allPlayersAfterInsert[0].id === myPlayerId;

                console.log('‚úÖ Joined lobby as:', username, 'ID:', myPlayerId, isHost ? '(HOST)' : '');

                // Hide join form, show ready controls
                document.getElementById('join-form').style.display = 'none';
                document.getElementById('ready-controls').style.display = 'block';

                // Start listening for updates
                subscribeToLobby();
                updateHeartbeat();
                updatePlayerList(); // Initial update to show host controls

            } catch (error) {
                console.error('Error joining lobby:', error);
                alert('Failed to join lobby: ' + error.message);

                // Re-enable inputs on error
                isJoining = false;
                joinButton.disabled = false;
                usernameInput.disabled = false;
                loadingDiv.style.display = 'none';
            }
        }

        // Leave the current game
        async function leaveGame() {
            if (!myPlayerId) return;

            const confirmed = confirm('‚ö†Ô∏è Leave Game?\n\nYou will be removed from this game and cannot rejoin.\n\nAre you sure?');
            if (!confirmed) return;

            try {
                console.log('üëã Leaving game...');

                // Delete myself from players table
                const { error } = await supabase
                    .from('players')
                    .delete()
                    .eq('id', myPlayerId);

                if (error) throw error;

                // Reset local state
                myPlayerId = null;
                myPlayerIndex = null;
                isHost = false;
                isMultiplayer = false;

                // Stop activity monitoring
                stopTurnTimerMonitoring();

                // Unsubscribe from channels
                if (playersSubscription) {
                    playersSubscription.unsubscribe();
                    playersSubscription = null;
                }
                if (gameRoomSubscription) {
                    gameRoomSubscription.unsubscribe();
                    gameRoomSubscription = null;
                }
                if (gameChannel) {
                    gameChannel.unsubscribe();
                    gameChannel = null;
                }

                // Reset UI
                document.getElementById('join-form').style.display = 'block';
                document.getElementById('ready-controls').style.display = 'none';
                document.getElementById('username-input').value = '';
                document.getElementById('leave-game').style.display = 'none';

                // Hide game, show lobby
                document.querySelector('.game-container').style.display = 'none';
                document.getElementById('multiplayer-lobby').style.display = 'block';

                // Clear the board
                clearBoard(true);

                console.log('‚úÖ Left game successfully');
                alert('You have left the game.');

            } catch (error) {
                console.error('Error leaving game:', error);
                alert('Failed to leave game: ' + error.message);
            }
        }

        // Reset the entire lobby (clear all players and reset game room)
        async function resetLobby() {
            const confirmed = confirm('‚ö†Ô∏è Reset Lobby?\n\nThis will:\n- Remove all players from the lobby\n- Reset the game room to waiting state\n- Clear the board if game has started\n\nAre you sure?');

            if (!confirmed) return;

            try {
                console.log('üîÑ Resetting lobby...');

                // Delete all players (get all IDs first, then delete)
                const { data: allPlayers } = await supabase
                    .from('players')
                    .select('id');

                if (allPlayers && allPlayers.length > 0) {
                    const { error: playersError } = await supabase
                        .from('players')
                        .delete()
                        .in('id', allPlayers.map(p => p.id));

                    if (playersError) throw playersError;
                }

                // Reset game room status
                const { error: roomError } = await supabase
                    .from('game_room')
                    .update({ status: 'waiting', current_turn_index: 0 })
                    .eq('id', 1);

                if (roomError) throw roomError;

                // Reset local state
                myPlayerId = null;
                isHost = false;
                isJoining = false;
                isMultiplayer = false;

                // Unsubscribe from channels
                if (playersSubscription) {
                    playersSubscription.unsubscribe();
                    playersSubscription = null;
                }
                if (gameRoomSubscription) {
                    gameRoomSubscription.unsubscribe();
                    gameRoomSubscription = null;
                }

                // Reset UI - show join form, hide ready controls
                document.getElementById('join-form').style.display = 'block';
                document.getElementById('ready-controls').style.display = 'none';
                document.getElementById('join-loading').style.display = 'none';
                document.getElementById('join-button').disabled = false;
                document.getElementById('username-input').disabled = false;
                document.getElementById('username-input').value = '';

                // Hide game, show lobby
                document.querySelector('.game-container').style.display = 'none';
                document.getElementById('multiplayer-lobby').style.display = 'block';

                // Clear the board if it was started
                clearBoard(true);

                console.log('‚úÖ Lobby reset complete!');
                alert('‚úÖ Lobby has been reset! You can now join again.');

            } catch (error) {
                console.error('Error resetting lobby:', error);
                alert('Failed to reset lobby: ' + error.message);
            }
        }

        // Handle game over - mark game as finished and show win screen
        async function handleGameOver(winnerPlayerIndex, winType = 'scrolls') {
            if (!isMultiplayer) return;

            try {
                console.log('üèÜ Game Over! Winner:', winnerPlayerIndex, 'Type:', winType);

                // Show win screen immediately for the winner
                showGameOverToAll(winnerPlayerIndex, winType);

                // Update game room status to 'finished'
                const { error } = await supabase
                    .from('game_room')
                    .update({
                        status: 'finished'
                    })
                    .eq('id', 1);

                if (error) {
                    console.error('Error updating game over state:', error);
                }
            } catch (error) {
                console.error('Error handling game over:', error);
            }
        }

        // Show game over notification to all players
        function showGameOverToAll(winnerPlayerIndex, winType = 'scrolls') {
            console.log('Game over for winner index:', winnerPlayerIndex, 'Type:', winType);

            // Check if notification already exists
            const existingNotification = document.getElementById('game-over-notification');
            if (existingNotification) {
                return; // Don't show duplicate
            }

            const notification = document.createElement('div');
            notification.id = 'game-over-notification';
            Object.assign(notification.style, {
                position: 'fixed', left: '50%', top: '50%',
                transform: 'translate(-50%, -50%)',
                backgroundColor: '#2c3e50', padding: '40px',
                borderRadius: '15px', boxShadow: '0 0 30px rgba(0,0,0,0.8)',
                zIndex: '1000', color: 'white', textAlign: 'center', minWidth: '500px',
                border: '3px solid gold'
            });

            const title = document.createElement('h1');
            title.textContent = 'GAME OVER';
            title.style.marginTop = '0';
            title.style.color = 'gold';
            title.style.fontSize = '42px';
            title.style.textShadow = '2px 2px 4px rgba(0,0,0,0.5)';
            notification.appendChild(title);

            // Show which player won using the new getPlayerColorName function
            const winnerName = getPlayerColorName(winnerPlayerIndex);

            const playerName = document.createElement('div');
            playerName.textContent = `${winnerName} wins!`;
            playerName.style.fontSize = '28px';
            playerName.style.fontWeight = 'bold';
            playerName.style.color = 'gold';
            playerName.style.marginBottom = '10px';
            notification.appendChild(playerName);

            const msg = document.createElement('div');
            if (winType === 'last_standing') {
                msg.textContent = 'Every other player left. You win!';
            } else {
                msg.textContent = 'All five elements have been mastered!';
            }
            msg.style.fontSize = '24px';
            msg.style.marginBottom = '10px';
            notification.appendChild(msg);

            // Only show elements if won by collecting scrolls
            if (winType === 'scrolls') {
                const elements = document.createElement('div');
                elements.style.fontSize = '32px';
                elements.style.margin = '20px 0';
                elements.innerHTML = '‚ñ≤ ‚óØ ‚ô¶ ‚âã ‚ú∫';
                notification.appendChild(elements);
            }

            const subtitle = document.createElement('div');
            subtitle.textContent = 'The path of balance is complete.';
            subtitle.style.fontSize = '16px';
            subtitle.style.fontStyle = 'italic';
            subtitle.style.color = '#bdc3c7';
            subtitle.style.marginBottom = '20px';
            notification.appendChild(subtitle);

            const lobbyBtn = document.createElement('button');
            lobbyBtn.textContent = 'Return to Lobby';
            lobbyBtn.style.padding = '12px 24px';
            lobbyBtn.style.fontSize = '16px';
            lobbyBtn.style.backgroundColor = 'gold';
            lobbyBtn.style.color = '#2c3e50';
            lobbyBtn.style.border = 'none';
            lobbyBtn.style.borderRadius = '5px';
            lobbyBtn.style.cursor = 'pointer';
            lobbyBtn.style.fontWeight = 'bold';
            lobbyBtn.onclick = () => {
                window.location.reload(); // Reload to return to lobby
            };
            notification.appendChild(lobbyBtn);

            document.body.appendChild(notification);
        }

        // Toggle ready status
        async function toggleReady() {
            if (!myPlayerId) return;
            
            try {
                // Get current ready state
                const { data: currentPlayer } = await supabase
                    .from('players')
                    .select('is_ready')
                    .eq('id', myPlayerId)
                    .single();
                
                const newReadyState = !currentPlayer.is_ready;
                
                // Update ready state
                const { error } = await supabase
                    .from('players')
                    .update({ is_ready: newReadyState })
                    .eq('id', myPlayerId);
                
                if (error) throw error;
                
                // Update button
                const readyButton = document.getElementById('ready-button');
                if (newReadyState) {
                    readyButton.textContent = 'Not Ready';
                    readyButton.style.background = '#f44336';
                } else {
                    readyButton.textContent = "I'm Ready!";
                    readyButton.style.background = '#4CAF50';
                }
                
            } catch (error) {
                console.error('Error toggling ready:', error);
            }
        }

        // Subscribe to lobby updates
        function subscribeToLobby() {
            // Unsubscribe from any existing channels first
            if (playersSubscription) {
                playersSubscription.unsubscribe();
            }
            if (gameRoomSubscription) {
                gameRoomSubscription.unsubscribe();
            }
            
            // Subscribe to players table
            playersSubscription = supabase
                .channel('players-channel-' + Math.random())
                .on('postgres_changes',
                    { event: '*', schema: 'public', table: 'players' },
                    async (payload) => {
                        console.log('Players update:', payload);

                        // Handle our own player being deleted (lobby reset)
                        if (payload.eventType === 'DELETE' && payload.old.id === myPlayerId) {
                            console.log('üîÑ You were removed from the lobby (reset detected)');

                            // Reset local state
                            myPlayerId = null;
                            isHost = false;
                            isMultiplayer = false;

                            // Unsubscribe from channels
                            if (playersSubscription) {
                                playersSubscription.unsubscribe();
                                playersSubscription = null;
                            }
                            if (gameRoomSubscription) {
                                gameRoomSubscription.unsubscribe();
                                gameRoomSubscription = null;
                            }

                            // Reset UI
                            document.getElementById('join-form').style.display = 'block';
                            document.getElementById('ready-controls').style.display = 'none';
                            document.getElementById('username-input').value = '';

                            // Hide game, show lobby
                            document.querySelector('.game-container').style.display = 'none';
                            document.getElementById('multiplayer-lobby').style.display = 'block';

                            alert('‚ö†Ô∏è Lobby was reset. Please join again.');
                            return; // Don't update player list since we're no longer in lobby
                        }

                        // Handle other players leaving during game
                        if (payload.eventType === 'DELETE' && payload.old.id !== myPlayerId) {
                            console.log('üëã Another player left:', payload.old);

                            // Show notification if game is in progress
                            const { data: room } = await supabase
                                .from('game_room')
                                .select('status')
                                .eq('id', 1)
                                .single();

                            if (room && room.status === 'playing') {
                                const leftPlayer = allPlayersData.find(p => p.id === payload.old.id);
                                const playerName = leftPlayer ? getPlayerColorName(leftPlayer.player_index) : 'A player';
                                updateStatus(`üëã ${playerName} left the game`);

                                // Check if I'm the only player left
                                const { data: remainingPlayers } = await supabase
                                    .from('players')
                                    .select('id');

                                console.log('üë• Remaining players after deletion:', remainingPlayers);
                                console.log('üîç My player ID:', myPlayerId);

                                if (remainingPlayers && remainingPlayers.length === 1 && remainingPlayers[0].id === myPlayerId) {
                                    console.log('I am the last player remaining - win by default!');
                                    console.log('My player index:', myPlayerIndex);

                                    // Mark game as finished with me as winner
                                    if (myPlayerIndex !== null && myPlayerIndex !== undefined) {
                                        console.log('Calling handleGameOver with index:', myPlayerIndex);
                                        await handleGameOver(myPlayerIndex, 'last_standing');
                                    } else {
                                        console.error('Cannot win - myPlayerIndex is null/undefined');
                                    }
                                } else {
                                    console.log('Still', remainingPlayers?.length || 0, 'players in game');
                                }
                            }
                        }

                        // Update our local isHost status when players change
                        // Check if we're now the first player (host)
                        if (myPlayerId) {
                            const { data: allPlayers } = await supabase
                                .from('players')
                                .select('*')
                                .order('created_at', { ascending: true });

                            if (allPlayers && allPlayers.length > 0) {
                                const wasHost = isHost;
                                isHost = allPlayers[0].id === myPlayerId;

                                // Notify if we became host
                                if (!wasHost && isHost) {
                                    console.log('üéñÔ∏è You are now the host!');
                                }
                            }
                        }

                        updatePlayerList();
                    }
                )
                .subscribe();
            
            // Subscribe to game_room table
            gameRoomSubscription = supabase
                .channel('game-room-channel-' + Math.random())
                .on('postgres_changes',
                    { event: '*', schema: 'public', table: 'game_room' },
                    (payload) => {
                        console.log('Game room update:', payload);
                        if (payload.new && payload.new.status === 'playing') {
                            handleGameStart();
                        } else if (payload.new && payload.new.status === 'finished') {
                            // Game ended - win screen is shown by handleGameOver directly
                            console.log('üèÅ Game finished!');
                        }
                    }
                )
                .subscribe();
            
            // Initial update
            updatePlayerList();
        }

        // Update player list display
        async function updatePlayerList() {
            try {
                const { data: players, error } = await supabase
                    .from('players')
                    .select('*')
                    .order('created_at', { ascending: true });

                if (error) throw error;

                const container = document.getElementById('players-container');
                if (!players || players.length === 0) {
                    container.innerHTML = '<p style="color: #999; font-style: italic;">No players yet...</p>';
                    return;
                }

                container.innerHTML = players.map((p, index) => {
                    const isMe = p.id === myPlayerId;
                    const readyIcon = p.is_ready ? '‚úì' : '‚óã';
                    const readyColor = p.is_ready ? '#4CAF50' : '#999';
                    const meLabel = isMe ? ' <span style="color: #ffd700;">(You)</span>' : '';
                    // First player in the list (index 0) is the host
                    const hostLabel = index === 0 ? ' <span style="color: #FF9800;">üëë Host</span>' : '';

                    return `
                        <div style="padding: 10px; margin: 5px 0; background: ${isMe ? '#444' : '#3a3a3a'}; border-radius: 5px; display: flex; justify-content: space-between; align-items: center;">
                            <span>${p.username}${hostLabel}${meLabel}</span>
                            <span style="color: ${readyColor}; font-size: 20px;">${readyIcon}</span>
                        </div>
                    `;
                }).join('');

                // Show/hide host settings panel
                const hostSettings = document.getElementById('host-settings');
                const totalCount = players.length;

                if (isHost && totalCount >= 2 && totalCount <= 5) {
                    hostSettings.style.display = 'block';
                } else {
                    hostSettings.style.display = 'none';
                }

                // Update status
                const statusDiv = document.getElementById('lobby-status');

                if (totalCount < 2) {
                    statusDiv.textContent = 'Waiting for more players... (need at least 2)';
                    statusDiv.style.color = '#999';
                } else if (totalCount > 5) {
                    statusDiv.textContent = 'Too many players! Maximum is 5.';
                    statusDiv.style.color = '#f44336';
                } else {
                    statusDiv.textContent = `${totalCount} players in lobby. Host can start the game!`;
                    statusDiv.style.color = '#4CAF50';
                }
                
            } catch (error) {
                console.error('Error updating player list:', error);
            }
        }

        // Host starts the game manually
        async function hostStartGame() {
            if (!isHost) {
                alert('Only the host can start the game!');
                return;
            }

            try {
                const { data: players, error } = await supabase
                    .from('players')
                    .select('*');

                if (error) throw error;

                // Validate player count
                if (players.length < 2) {
                    alert('Need at least 2 players to start!');
                    return;
                }

                if (players.length > 5) {
                    alert('Too many players! Maximum is 5.');
                    return;
                }

                console.log('üéÆ Host starting game with', players.length, 'players...');

                // Get turn timer settings
                const timeoutSelect = document.getElementById('timeout-setting');
                const turnTimeLimit = parseInt(timeoutSelect.value, 10) * 1000; // seconds -> ms
                const kickCheckbox = document.getElementById('kick-on-timeout');
                const kickMode = !!(kickCheckbox && kickCheckbox.checked);

                console.log('‚è±Ô∏è Turn time limit set to:', turnTimeLimit / 1000, 'seconds');
                console.log('üë¢ Kick on turn timeout:', kickMode);

                // Randomly assign player indices and colors
                const colorRankOrder = ['purple', 'yellow', 'red', 'blue', 'green'];
                const shuffledIndices = [...Array(players.length).keys()].sort(() => Math.random() - 0.5);

                // Update game room status to trigger game start and store turn-timer settings
                const startedAtIso = new Date().toISOString();

                // Try writing extended fields; if the DB schema doesn't have them, fall back gracefully.
                let { error: roomError } = await supabase
                    .from('game_room')
                    .update({
                        status: 'playing',
                        current_turn_index: 0,
                        inactivity_timeout: turnTimeLimit,        // reused as turn time limit (ms)
                        kick_on_turn_timeout: kickMode,
                        turn_started_at: startedAtIso
                    })
                    .eq('id', 1);

                if (roomError) {
                    console.warn('‚ö†Ô∏è Failed to write extended turn timer fields to game_room. Falling back to basic fields.', roomError);
                    const fallback = await supabase
                        .from('game_room')
                        .update({
                            status: 'playing',
                            current_turn_index: 0,
                            inactivity_timeout: turnTimeLimit
                        })
                        .eq('id', 1);

                    roomError = fallback.error;
                }

                if (roomError) throw roomError;

                // Also set local host timer baseline immediately
                gameInactivityTimeout = turnTimeLimit;
                kickOnTurnTimeout = kickMode;
                turnStartedAtMs = Date.now();

                // Assign colors and indices to players
                for (let i = 0; i < players.length; i++) {
                    const player = players[i];
                    const assignedIndex = shuffledIndices[i];
                    const assignedColor = colorRankOrder[assignedIndex];

                    await supabase
                        .from('players')
                        .update({
                            player_index: assignedIndex,
                            color: assignedColor
                        })
                        .eq('id', player.id);
                }

                console.log('‚úÖ Game started by host!');

            } catch (error) {
                console.error('Error starting game:', error);
                alert('Failed to start game: ' + error.message);
            }
        }

        // Check if game should start (DEPRECATED - now host-controlled)
        async function checkGameStart() {
            try {
                const { data: players, error } = await supabase
                    .from('players')
                    .select('*');
                
                if (error) throw error;
                
                // Need at least 2 players, max 5
                if (players.length < 2 || players.length > 5) return;
                
                // Check if all ready
                const allReady = players.every(p => p.is_ready);
                if (!allReady) return;
                
                console.log('üéÆ All players ready! Starting game...');
                
                // Randomly assign player indices and colors
                const colorRankOrder = ['purple', 'yellow', 'red', 'blue', 'green'];
                const shuffledIndices = [...Array(players.length).keys()].sort(() => Math.random() - 0.5);
                
                // Update game room status
                const { error: roomError } = await supabase
                    .from('game_room')
                    .update({ status: 'playing', current_turn_index: 0 })
                    .eq('id', 1);
                
                if (roomError) throw roomError;
                
                // Assign colors and indices to players
                for (let i = 0; i < players.length; i++) {
                    const player = players[i];
                    const assignedIndex = shuffledIndices[i];
                    const assignedColor = colorRankOrder[assignedIndex];
                    
                    await supabase
                        .from('players')
                        .update({ 
                            player_index: assignedIndex, 
                            color: assignedColor 
                        })
                        .eq('id', player.id);
                }
                
            } catch (error) {
                console.error('Error checking game start:', error);
            }
        }

        // Handle game start
        async function handleGameStart() {
            try {
                // Wait for player_index to be assigned (retry up to 10 times)
                let myPlayer = null;
                let attempts = 0;
                
                while (attempts < 10) {
                    const { data, error } = await supabase
                        .from('players')
                        .select('*')
                        .eq('id', myPlayerId)
                        .single();
                    
                    if (error) throw error;
                    
                    if (data.player_index !== null && data.player_index !== undefined) {
                        myPlayer = data;
                        break;
                    }
                    
                    console.log(`‚è≥ Waiting for player index assignment (attempt ${attempts + 1}/10)...`);
                    await new Promise(resolve => setTimeout(resolve, 300));
                    attempts++;
                }
                
                if (!myPlayer || myPlayer.player_index === null) {
                    throw new Error('Player index was not assigned');
                }
                
                myPlayerIndex = myPlayer.player_index;
                
                // Get all players
                const { data: allPlayers } = await supabase
                    .from('players')
                    .select('*')
                    .order('player_index', { ascending: true });
                
                console.log('üéÆ Starting multiplayer game!');
                console.log('My index:', myPlayerIndex);
                console.log('My color:', myPlayer.color);
                console.log('All players:', allPlayers);
                
                // Get game room settings (turn timer)
                // We select '*' for forward/backward compatibility if columns are missing.
                const { data: room } = await supabase
                    .from('game_room')
                    .select('*')
                    .eq('id', 1)
                    .single();

                if (room && room.inactivity_timeout !== null && room.inactivity_timeout !== undefined) {
                    gameInactivityTimeout = room.inactivity_timeout; // reused as turn time limit (ms)
                    console.log('‚è±Ô∏è Loaded turn time limit:', gameInactivityTimeout / 1000, 'seconds');
                }

                if (room && room.kick_on_turn_timeout !== null && room.kick_on_turn_timeout !== undefined) {
                    kickOnTurnTimeout = !!room.kick_on_turn_timeout;
                    console.log('üë¢ kickOnTurnTimeout:', kickOnTurnTimeout);
                }

                // Host will broadcast turnStartedAt, but set a sensible baseline
                if (room && room.turn_started_at) {
                    const ts = new Date(room.turn_started_at).getTime();
                    if (!Number.isNaN(ts)) turnStartedAtMs = ts;
                } else {
                    turnStartedAtMs = Date.now();
                }

                // Hide lobby, show game
                document.getElementById('multiplayer-lobby').style.display = 'none';
                document.querySelector('.game-container').style.display = 'flex';
                updateDeckIndicatorVisibility();

                // Show leave game button in multiplayer
                document.getElementById('leave-game').style.display = 'inline-block';

                // Start turn timer monitoring (turn-based timeout)
                startTurnTimerMonitoring();

                // Initialize game with multiplayer players
                startMultiplayerGame(allPlayers);
                
            } catch (error) {
                console.error('Error handling game start:', error);
                alert('Failed to start game: ' + error.message);
            }
        }

        // Update heartbeat (keep player active)
        function updateHeartbeat() {
            if (!myPlayerId) return;

            // REMOVED: Automatic heartbeat was preventing timeout kicks
            // Players' last_seen is updated only when they make moves via recordActivity()
            // This allows the inactivity timeout to properly detect and kick inactive players

            // setInterval(async () => {
            //     // Don't update if we're no longer in the lobby
            //     if (!myPlayerId) return;

            //     try {
            //         await supabase
            //             .from('players')
            //             .update({ last_seen: new Date().toISOString() })
            //             .eq('id', myPlayerId);
            //     } catch (error) {
            //         console.error('Heartbeat error:', error);
            //     }
            // }, 30000); // Every 30 seconds
        }

        // Clean up on page unload (synchronous to ensure it completes)
        window.addEventListener('beforeunload', (e) => {
            if (myPlayerId) {
                // Use navigator.sendBeacon for reliable cleanup during page unload
                const supabaseUrl = supabase.supabaseUrl;
                const supabaseKey = supabase.supabaseKey;

                // Direct REST API call using fetch with keepalive
                fetch(`${supabaseUrl}/rest/v1/players?id=eq.${myPlayerId}`, {
                    method: 'DELETE',
                    headers: {
                        'apikey': supabaseKey,
                        'Authorization': `Bearer ${supabaseKey}`,
                        'Content-Type': 'application/json'
                    },
                    keepalive: true // This ensures the request completes even if page closes
                });
            }
        });

        // NOTE: Removed visibilitychange cleanup - it was kicking players out when switching tabs
        // This was problematic for development. The beforeunload handler is sufficient.

        let gameChannel = null; // Global reference to the game broadcast channel

        // Set up broadcast channel for real-time game synchronization
        function setupGameBroadcast() {
            if (gameChannel) {
                gameChannel.unsubscribe();
            }

            // Create a channel for this game room
            gameChannel = supabase.channel('game-room-1', {
                config: {
                    broadcast: { self: false } // Don't receive our own broadcasts
                }
            });

            // Listen for tile flip events
            gameChannel.on('broadcast', { event: 'tile-flip' }, ({ payload }) => {
                console.log('üîÑ Received tile flip broadcast:', payload);
                const { tileId, shrineType } = payload;
                // Find the tile and flip it
                const tile = document.querySelector(`[data-tile-id="${tileId}"]`);
                if (tile) {
                    console.log(`‚úÖ Found tile ${tileId}, flipping to ${shrineType}`);
                    flipTileVisually(tile, shrineType);
                } else {
                    console.error(`‚ùå Could not find tile with id ${tileId} in DOM`);
                }
            });

            // Listen for stone placement events
            gameChannel.on('broadcast', { event: 'stone-place' }, ({ payload }) => {
                console.log('üîÑ Received stone placement:', payload);
                const { x, y, stoneType } = payload;
                placeStoneVisually(x, y, stoneType);
            });

            // Listen for stone break events
            gameChannel.on('broadcast', { event: 'stone-break' }, ({ payload }) => {
                console.log('üîÑ Received stone break:', payload);
                const { stoneId } = payload;
                breakStoneVisually(stoneId);
            });

            // Listen for player tile placement events
            gameChannel.on('broadcast', { event: 'player-tile-place' }, ({ payload }) => {
                console.log('üîÑ Received player tile placement:', payload);
                const { x, y, playerIndex, color } = payload;
                placePlayerTileVisually(x, y, playerIndex, color);
            });

            // Listen for player movement events
            gameChannel.on('broadcast', { event: 'player-move' }, ({ payload }) => {
                console.log('üîÑ Received player movement:', payload);
                const { playerIndex, x, y, apSpent } = payload;
                movePlayerVisually(playerIndex, x, y, apSpent);
            });

            // Listen for turn change events
            gameChannel.on('broadcast', { event: 'turn-change' }, ({ payload }) => {
                console.log('üîÑ Received turn-change:', payload.playerIndex, 'myPlayerIndex:', myPlayerIndex, 'isPlacementPhase:', isPlacementPhase);
                activePlayerIndex = payload.playerIndex;
                if (payload.turnStartedAt) {
                    turnStartedAtMs = payload.turnStartedAt;
                } else {
                    turnStartedAtMs = Date.now();
                }

                updateEndTurnButtonVisibility();
            updateDeckIndicatorVisibility();

                if (isPlacementPhase) {
                    // During placement, update status for tile placement
                    if (canPlaceTile()) {
                        updateStatus(`Your turn! Place your player tile (${playerTilesPlaced.size}/${totalPlayers} placed)`);
                        setInventoryOpen(true);
                        console.log(`‚úÖ My turn to place tile`);
                    } else {
                        const nextColorName = getPlayerColorName(activePlayerIndex);
                        updateStatus(`Waiting for ${nextColorName} to place their tile... (${playerTilesPlaced.size}/${totalPlayers})`);
                        console.log(`‚è≥ Waiting for player ${activePlayerIndex} to place`);
                    }
                } else {
                    // Normal gameplay turn display
                    updateTurnDisplay();
                }
            });

            // Listen for player tile placement during placement phase
            gameChannel.on('broadcast', { event: 'player-tile-placed' }, ({ payload }) => {
                console.log('üîÑ Player tile placed:', payload);
                const { playerIndex } = payload;
                playerTilesPlaced.add(playerIndex);

                // Don't check completion here - let placement-complete event handle it
                if (isPlacementPhase && playerTilesPlaced.size < totalPlayers) {
                    // Update status during placement phase
                    if (canPlaceTile()) {
                        updateStatus(`Your turn! Place your player tile (${playerTilesPlaced.size}/${totalPlayers} placed)`);
                        setInventoryOpen(true);
                    } else {
                        const nextColorName = getPlayerColorName(activePlayerIndex);
                        updateStatus(`Waiting for ${nextColorName} to place their tile... (${playerTilesPlaced.size}/${totalPlayers})`);
                    }
                }
            });

            // Listen for placement phase completion
            gameChannel.on('broadcast', { event: 'placement-complete' }, ({ payload }) => {
                console.log('üîÑ Placement phase complete');
                isPlacementPhase = false;
                activePlayerIndex = payload.playerIndex; // Set to first player
                if (payload.turnStartedAt) {
                    turnStartedAtMs = payload.turnStartedAt;
                } else {
                    turnStartedAtMs = Date.now();
                }

                if (isMyTurn()) {
                    updateStatus(`‚úÖ All tiles placed! It's your turn!`);
                } else {
                    const firstPlayerColorName = getPlayerColorName(activePlayerIndex);
                    updateStatus(`‚úÖ All tiles placed! Waiting for ${firstPlayerColorName}'s turn...`);
                }
            });

            // Listen for spell cast events
            gameChannel.on('broadcast', { event: 'spell-cast' }, ({ payload }) => {
                console.log('üîÑ Received spell cast:', payload);
                const { playerIndex, spellName, element, elements, level, isCatacomb } = payload;

                // Update that player's activated elements display
                if (isCatacomb) {
                    // Catacomb activates multiple elements
                    elements.forEach(el => {
                        spellSystem.getPlayerScrolls(playerIndex === myPlayerIndex).activated.add(el);
                    });
                } else {
                    // Regular spell activates one element
                    spellSystem.getPlayerScrolls(playerIndex === myPlayerIndex).activated.add(element);
                }

                // Update the element symbols display for that player
                updatePlayerElementSymbols(playerIndex);

                // Show notification
                const playerName = getPlayerColorName(playerIndex);
                if (isCatacomb) {
                    updateStatus(`‚ú® ${playerName} cast ${spellName}! Activated: ${elements.join(', ')}`);
                } else {
                    updateStatus(`‚ú® ${playerName} cast ${spellName}! Activated ${element} (level ${level})`);
                }
            });

            // Listen for undo move events
            gameChannel.on('broadcast', { event: 'undo-move' }, ({ payload }) => {
                console.log('üîÑ Received undo move:', payload);
                const { playerIndex, x, y, apRestored } = payload;

                // Visually move the player back
                movePlayerVisually(playerIndex, x, y, -apRestored); // Negative to show AP restored

                const playerName = getPlayerColorName(playerIndex);
                updateStatus(`‚Ü©Ô∏è ${playerName} undid their move (restored ${apRestored} AP)`);
            });

            // Listen for player state updates (AP and resources)
            gameChannel.on('broadcast', { event: 'player-state-update' }, ({ payload }) => {
                console.log('üîÑ Received player state update:', payload);
                const { playerIndex, currentAP, voidAP, resources } = payload;

                // Update tracked state for this player
                if (!playerAPs[playerIndex]) {
                    playerAPs[playerIndex] = { currentAP: 5, voidAP: 0 };
                }
                playerAPs[playerIndex].currentAP = currentAP;
                playerAPs[playerIndex].voidAP = voidAP;

                // Update resources
                if (!playerPools[playerIndex]) {
                    playerPools[playerIndex] = { earth: 0, water: 0, fire: 0, wind: 0, void: 0 };
                }
                Object.assign(playerPools[playerIndex], resources);
            });

            // Listen for scroll collection events
            gameChannel.on('broadcast', { event: 'scroll-collected' }, ({ payload }) => {
                console.log('üîÑ Received scroll collection:', payload);
                const { playerIndex, scrollName, shrineType } = payload;

                // Remove from available pool
                spellSystem.availableScrolls[shrineType].delete(scrollName);

                // Add to that player's collection
                if (!spellSystem.playerScrolls[playerIndex]) {
                    spellSystem.playerScrolls[playerIndex] = {
                        collected: new Set(),
                        activated: new Set()
                    };
                }
                spellSystem.playerScrolls[playerIndex].collected.add(scrollName);

                const playerName = getPlayerColorName(playerIndex);
                updateStatus(`üìú ${playerName} collected a ${shrineType} scroll!`);
            });

            // Subscribe to the channel
            gameChannel.subscribe((status) => {
                if (status === 'SUBSCRIBED') {
                    console.log('‚úÖ Connected to game broadcast channel');
                }
            });
        }

        // Broadcast a game action to all other players
        function broadcastGameAction(event, payload) {
            if (!gameChannel || !isMultiplayer) return;

            gameChannel.send({
                type: 'broadcast',
                event: event,
                payload: payload
            });
        }

        // Start multiplayer game
        function startMultiplayerGame(allPlayers) {
            // Clear the board first (skip confirmation in multiplayer)
            clearBoard(true);

            // Reset color assignments for this game
            gameSessionColors.clear();

            // Store player data globally for color name lookups
            allPlayersData = allPlayers;

            const numPlayers = allPlayers.length;
            console.log(`üéÆ Starting multiplayer game with ${numPlayers} players`);
            console.log('All players:', allPlayers);

            // Find my player data
            const myPlayer = allPlayers.find(p => p.id === myPlayerId);
            if (!myPlayer) {
                console.error('Could not find my player data!');
                return;
            }

            // Set my assigned color
            playerColor = myPlayer.color;
            console.log(`üé® I am player ${myPlayer.player_index + 1} (${playerColor})`);

            // Set activePlayerIndex to first player (player_index 0 = purple/void)
            activePlayerIndex = 0;

            // Initialize placement phase tracking
            totalPlayers = numPlayers;
            playerTilesPlaced = new Set();
            isPlacementPhase = true;
            console.log(`üéÆ Placement phase initialized: activePlayerIndex=${activePlayerIndex}, totalPlayers=${totalPlayers}, myPlayerIndex=${myPlayer.player_index}`);

            // Set up broadcast channel for game actions
            setupGameBroadcast();

            // Initialize deck
            initializeDeck(numPlayers);

            // In multiplayer, only show MY player tile
            initializeMyPlayerTile(myPlayer.player_index, myPlayer.color);

            Object.keys(stoneCounts).forEach(updateStoneCount);
            updateVoidAP(); // Initialize void AP display
            drawDeckTile();
            updateViewport();
            boardSvg.style.cursor = 'grab';

            // Calculate number of tiles (6 per player)
            const numTiles = numPlayers * 6;

            // Place hidden tiles in spiral pattern
            const spiralPositions = generateSpiralPositions(numTiles);
            console.log(`Placing ${numTiles} tiles for ${numPlayers} player(s)`);
            spiralPositions.forEach((pos, index) => {
                console.log(`Tile ${index + 1}: (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)})`);
                placeTile(pos.x, pos.y, 0, true); // Place as flipped (hidden)
            });

            // Show appropriate message based on turn order
            if (myPlayer.player_index === 0) {
                updateStatus(`üéÆ You are Player ${myPlayer.player_index + 1} (${playerColor})! It's your turn - drag your player tile to the board to start.`);
            } else {
                updateStatus(`‚è≥ You are Player ${myPlayer.player_index + 1} (${playerColor}). Waiting for other players to place their tiles...`);
            }
        }


        // Start game with selected number of players (local mode)
        function startGame(numPlayers) {
            // Clear the board first
            clearBoard();

            // Reset color assignments for this game
            gameSessionColors.clear();
            playerColor = null;
            console.log(`üé® Starting game with ${numPlayers} player(s). Colors will be assigned as player tiles are placed.`);

            // Hide player selection menu
            document.getElementById('player-selection').style.display = 'none';
            document.querySelector('.game-container').style.display = 'flex';
                updateDeckIndicatorVisibility();

            // Calculate number of tiles (6 per player)
            const numTiles = numPlayers * 6;

            // Initialize
            initializeDeck(numPlayers); // Shuffle the tile deck
            initializePlayerTiles(numPlayers); // Create player tiles
            Object.keys(stoneCounts).forEach(updateStoneCount);
            updateVoidAP(); // Initialize void AP display
            drawDeckTile();
            updateViewport();
            boardSvg.style.cursor = 'grab';

            // Place hidden tiles in spiral pattern
            const spiralPositions = generateSpiralPositions(numTiles);
            console.log(`Placing ${numTiles} tiles for ${numPlayers} player(s)`);
            spiralPositions.forEach((pos, index) => {
                console.log(`Tile ${index + 1}: (${pos.x.toFixed(1)}, ${pos.y.toFixed(1)})`);
                placeTile(pos.x, pos.y, 0, true); // Place as flipped (hidden)
            });

            updateStatus(`Game started with ${numPlayers} player(s) (${numTiles} tiles). Drag a player tile from the Player Tiles deck to start.`);

            // Initialize / refresh mobile UI based on current viewport (supports devtools device toolbar)
            updateIsMobile();
            window.addEventListener('resize', updateIsMobile);
            try { window.matchMedia('(max-width: 768px)').addEventListener('change', updateIsMobile); } catch (e) {}
}

        // Mobile UI initialization and tab switching
        function initializeMobileUI() {
            const tabButtons = document.querySelectorAll('.mobile-tab-btn');
            const tilesPanel = document.getElementById('mobile-tiles-panel');
            const stonesPanel = document.getElementById('mobile-stones-panel');
            let currentTab = 'tiles';

            // Tab switching logic
            tabButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const tab = btn.dataset.tab;

                    // Update active tab button
                    tabButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    // Show/hide panels
                    if (tab === 'tiles') {
                        tilesPanel.classList.add('active');
                        stonesPanel.classList.remove('active');
                        currentTab = 'tiles';
                        syncMobileTileDeck();
                    } else {
                        stonesPanel.classList.add('active');
                        tilesPanel.classList.remove('active');
                        currentTab = 'stones';
                        syncMobileStoneDeck();
                    }
                });
            });

            // Swipe gesture for tab switching
            let touchStartX = 0;
            let touchEndX = 0;

            const mobileContainer = document.querySelector('.mobile-deck-container');

            mobileContainer.addEventListener('touchstart', (e) => {
                touchStartX = e.changedTouches[0].screenX;
            }, { passive: true });

            mobileContainer.addEventListener('touchend', (e) => {
                touchEndX = e.changedTouches[0].screenX;
                handleSwipe();
            }, { passive: true });

            function handleSwipe() {
                const swipeThreshold = 50;
                const diff = touchStartX - touchEndX;

                if (Math.abs(diff) > swipeThreshold) {
                    if (diff > 0 && currentTab === 'tiles') {
                        // Swiped left - switch to stones
                        tabButtons[1].click();
                    } else if (diff < 0 && currentTab === 'stones') {
                        // Swiped right - switch to tiles
                        tabButtons[0].click();
                    }
                }
            }

            // Initialize with tiles tab active
            syncMobileTileDeck();
            syncMobileStoneDeck();
        }

        
        // Programmatically open a mobile deck tab (tiles/stones)
        function openMobileTab(tab) {
            if (!isMobile) return;
            const tabButtons = document.querySelectorAll('.mobile-tab-btn');
            const tilesPanel = document.getElementById('mobile-tiles-panel');
            const stonesPanel = document.getElementById('mobile-stones-panel');

            tabButtons.forEach(b => b.classList.remove('active'));
            const btn = Array.from(tabButtons).find(b => b.dataset.tab === tab);
            if (btn) btn.classList.add('active');

            if (tab === 'tiles') {
                tilesPanel.classList.add('active');
                stonesPanel.classList.remove('active');
                syncMobileTileDeck();
            } else {
                stonesPanel.classList.add('active');
                tilesPanel.classList.remove('active');
                syncMobileStoneDeck();
            }
        }

        function setMobileDeckCollapsed(collapsed) {
            const container = document.querySelector('.mobile-deck-container');
            if (!container) return;
            if (collapsed) container.classList.add('collapsed');
            else container.classList.remove('collapsed');
        }


// Sync mobile tile deck with desktop deck
        function syncMobileTileDeck() {
            if (!isMobile) return;

            const mobileGrid = document.getElementById('mobile-tile-grid');
            mobileGrid.innerHTML = '';

            // Add player tiles
            playerTileElements.forEach((tileElement, index) => {
                const clone = tileElement.cloneNode(true);
                clone.style.touchAction = 'none';
                clone.addEventListener('touchstart', (e) => {
                    if (playerTilesAvailable <= 0) return;
                    if (isMultiplayer && isPlacementPhase && !canPlaceTile()) {
                        notYourTurn();
                        return;
                    }
                    e.preventDefault();
                    startPlayerTileDrag(index, e);
                }, { passive: false });

                mobileGrid.appendChild(clone);
            });

            // Update count
            document.getElementById('mobile-tile-count').textContent = playerTilesAvailable;
        }

        // Sync mobile stone deck with desktop deck
        function syncMobileStoneDeck() {
            if (!isMobile) return;

            const mobileGrid = document.getElementById('mobile-stone-grid');
            mobileGrid.innerHTML = '';

            ['earth', 'water', 'fire', 'wind', 'void'].forEach(type => {
                const stoneItem = document.createElement('div');
                stoneItem.className = 'stone-deck-item';
                stoneItem.style.touchAction = 'none';

                stoneItem.innerHTML = `
                    <svg width="40" height="40">
                        <circle cx="20" cy="20" r="12" fill="${STONE_TYPES[type].color}" class="stone-piece"/>
                        <text x="20" y="20" text-anchor="middle" dominant-baseline="middle" fill="#fff" font-size="14" font-weight="bold">${STONE_TYPES[type].symbol}</text>
                    </svg>
                    <div class="stone-count">${playerPool[type]}/${stoneCapacity}</div>
                    <div class="source-count">${stoneCounts[type]}/${Object.keys(shuffledDeck).filter(key => shuffledDeck[key].stoneType === type).length}</div>
                `;

                stoneItem.addEventListener('touchstart', (e) => {
                    if (stoneCounts[type] <= 0) return;
                    e.preventDefault();

                    isDraggingStone = true;
                    draggedStoneId = null;
                    draggedStoneType = type;

                    const rect = boardSvg.getBoundingClientRect();
                    const coords = getEventCoords(e);
                    const screenX = coords.x - rect.left;
                    const screenY = coords.y - rect.top;
                    const world = screenToWorld(screenX, screenY);

                    ghostStone = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    ghostStone.setAttribute('class', 'stone stone-ghost');
                    ghostStone.setAttribute('transform', `translate(${world.x}, ${world.y})`);

                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', 0);
                    circle.setAttribute('cy', 0);
                    circle.setAttribute('r', STONE_SIZE);
                    circle.setAttribute('class', 'stone-piece');
                    circle.setAttribute('fill', STONE_TYPES[type].color);

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', 0);
                    text.setAttribute('y', 0);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('dominant-baseline', 'middle');
                    text.setAttribute('fill', '#fff');
                    text.setAttribute('font-size', '14');
                    text.setAttribute('font-weight', 'bold');
                    text.textContent = STONE_TYPES[type].symbol;

                    ghostStone.appendChild(circle);
                    ghostStone.appendChild(text);
                    viewport.appendChild(ghostStone);
                }, { passive: false });

                mobileGrid.appendChild(stoneItem);
            });
        }

        // Lock screen orientation to portrait on mobile (if supported)
        if (isMobile && screen.orientation && screen.orientation.lock) {
            screen.orientation.lock('portrait').catch(err => {
                console.log('Could not lock orientation:', err);
            });
        }
    
        // Initialize button visibility on load
        try { updateEndTurnButtonVisibility(); } catch (e) {}
</script>
</body>
</html>